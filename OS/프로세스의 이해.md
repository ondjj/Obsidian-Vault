---
sticker: lucide//circle-ellipsis
---
## Process Concept

프로세스는 실행 중인 프로그램을 나타내며, 운영체제는 이를 작업의 기본 단위로 활용합니다.
- 프로세스는 작업을 수행하기 위해 아래와 같은 특정 리소스가 필요합니다.
	- CPU time
	- memory
	- files or I/O devices (resource)

일반적으로 CPU는 직접 스토리지에 저장된 프로그램을 실행하지 않으며, 프로그램은 메모리에 로드되어야 합니다. 이때 메모리에 로드된 프로그램을 실행 중인 프로세스라고 할 수 있습니다.

### 프로세스의 메모리 레이아웃

프로세스의 메모리 레이아웃은 아래와 같이 여러 섹션으로 나뉩니다.
![2NTmbQe.png](https://i.imgur.com/2NTmbQe.png)
• **Text section**:
- 실행 코드

• **Data section**:
- 전역 변수

• **Heap section**:
- 프로그램 실행 시간 동안 동적으로 할당되는 메모리 (자바의 경우 new 키워드)

• **Stack section**:
- 함수를 호출할 때 사용되는 임시 데이터 저장소
- function parameters, return addresses and local variables

![](https://i.imgur.com/be84ExN.png)

위와 같은 코드가 컴파일 되어 실행된다면 하나의 프로세스로 취급되어 운영 체제의 관리 대상이 된다.

### 프로세스의 상태 종류

프로세스는 실행된 후 상태가 변경됩니다.  
  
• **New**: 프로세스가 생성된 상태
• **Running**: 명령 실행 중
• **Waiting**: 프로세스가 일부 이벤트가 발생하기를 기다리고 있습니다.  
- I/O completion 또는 reception of a signal.
• **Ready**: 프로세스가 프로세서에 할당되기를 기다리고 있습니다.  
• **Terminated**: 프로세스 실행 종료

![](https://i.imgur.com/ygMuMia.png)

### 프로세스 관리

#### PCB (Process Control Block)

각 프로세스는 PCB로 운영 체제에 표시되는데 PCB에는 프로세스가 가져야하는 모든 정보가 포함되어 있습니다. (Task Control Block TCB 라고도 불립니다.)
#### PCB에 포함되는 정보의 종류 :

![](https://i.imgur.com/K9X4qX3.png)

• Process state : new / running / wait / ready ..  
• Program counter : 실행 번지 저장소
• CPU 레지스터 : IR / DR ..
• CPU 스케줄링 정보  
• 메모리 관리 정보  
• Accounting information  
• I/O status information

#### 프로세스 특징

프로세스는 다음과 같은 특징을 가지고 있습니다:

- 프로세스는 단일 실행 스레드를 수행하는 프로그램입니다.
- 이 단일 제어 스레드를 통해 프로세스는 한 번에 하나의 작업만 수행할 수 있습니다.
- 하지만 현대의 운영체제는 프로세스가 여러 실행 스레드를 가질 수 있도록 확장되어 있어, 한 번에 여러 작업을 수행할 수 있습니다.

## Process Scheduling 기법

**Multiprogramming:**
multiprogramming의 목적은 동시에 여러 개의 프로세스를 실행 시키는데 있는데 이는 CPU의 사용 효율을 최대로 올리기 위해서입니다.

**Time sharing:**
time sharing은 CPU를 점유하는 프로세스를 빈번하게 변경하여 사용자로 하여금 프로그램이 동시에 사용되는것처럼 보이게 하는것을 목표로 하는 기법입니다.

위와 같이 여러 개의 Process를 사용하는 방법이 존재할 때 이를 관리(Scheduling) 하는 기법 역시 필요한데 주로 Scheduling Queues를 통해 이루어집니다.

**Scheduling Queues:**
- Queue는 FIFO 구조를 갖는 자료 구조로 프로세스가 시스템에 진입하면 ready queue에 들어가게 되며, 여기서는 CPU 코어에서 실행될 준비가 되어 대기합니다.
- 특정 이벤트를 기다리는 프로세스는 대기 큐에 배치됩니다.
- 이러한 큐는 일반적으로 PCB들의 linked list로 구현됩니다.

![](https://i.imgur.com/qaqWXNZ.png)

Queueing에 대해 좀 더 세분화 해서 내부를 들여다 본다면 아래와 같은 다이어그램을 갖을 수 있습니다.
![](https://i.imgur.com/KnvWduj.png)
1. `ready queue`에 존재하는 프로세스가 CPU를 획득한 후 종료되었다가 다시 `ready queue`로 들어가는 경우가 있을 수 있습니다.
2. I/0 request가 오면 I/O queue로 들어간 후 I/O 작업을 하고 다시 `ready queue`로 들어갈 수 있습니다.
3. time slice가 만료되었을 경우 다시 `ready queue`로 들어갈 수 있습니다.
4. CPU가 child를 fork한 경우 `new` 상태가 되기 때문에 child process가 `ready queue`로 들어갈 수 있습니다.
5. 마지막으로 특정 interrupt가 발생할 경우 `ready queue`로 들어갈 수 있습니다.


## Context Switch

프로세스 입장에서 Context란 사용되고 있는 상태를 의미한다고 볼 수 있고 그 상태는 모두 PCB에 저장되어있습니다. (OS 입장에서 문맥 교환이란 PCB를 변경하는것입니다.)

#### 인터럽트가 발생할 경우
- 시스템은 현재 실행 중인 프로세스의 현재 상태를 저장합니다.
- 나중에 해당 상태를 다시 시작해야 할 때, 시스템이 이를 복원할 수 있도록 합니다.
#### Context switch 과정
![](https://i.imgur.com/99Dof01.png)
- CPU 코어를 다른 프로세스로 전환합니다.
- 현재 프로세스의 상태를 저장합니다.
- 다른 프로세스의 상태를 복원합니다.
