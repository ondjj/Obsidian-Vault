---
sticker: lucide//save
---
# 사용 목적


# 성능


# 데이터베이스 풀

## Connection Pool

클라이언트의 요청에 따라 어플리케이션에서 데이터베이스에 접근하기 위해서는 연결이 필요하고 요청에 따라 데이터베이스에 대한 연결을 생성하는 것은 비용적인 측면에서 리스크가 크기 때문에 사용량에 따라 적정량의 커넥션을 미리 생성해 놓고 유지 관리 및 삭제함으로써 리소스를 최적화 하고 관련된 오버헤드 비용을 줄일 필요가 있다.

![](https://i.imgur.com/C1hYRxX.png)


`Connection pool`은 이를 해결하기 위한 방법으로 연결을 여러 개 생성하고 공간(주로 캐시)에 저장해 이 공간의 Connection을 필요할 때 꺼내 쓰고 반환하는 기법을 말한다. 이는 풀의 기존 연결을 재사용함으로써 모든 요청에 대해 새 연결을 설정하는데 관련된 리소스 집약적인 프로세스를 최소화 하는데 효과적이다.(새로운 연결을 설정하는데 드는 비용에는 네트워크 대기 시간, 인증 및 리소스 할당 등이 포함된다.)

## DB 접근 단계
```
1. 애플리케이션 로직은 DB 드라이버를 통해 커넥션을 조회한다.
2. DB 드라이버는 DB와 TCP/IP 커넥션을 연결한다. 물론 이 과정에서 3 way handshake 같은 TCP/IP
연결을 위한 네트워크 동작이 발생한다.
3. DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW와 기타 부가정보를 DB에 전달한다.
4. DB는 ID, PW를 통해 내부 인증을 완료하고, 내부에 DB 세션을 생성한다.
5. DB는 커넥션 생성이 완료되었다는 응답을 보낸다.
6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.
```
이렇게 요청에 따라 그때 그때 커넥션을 만들게 된다면 DB는 물론, 애플리케이션 서버도 TCP/IP 커넥션을 새로 생성하기 때문에 불필요한 리소스 낭비를 유발하게 되고 자연스레 고객이 애플리케이션을 사용할 때 SQL을 실행하는 시간 뿐만 아니라 커넥션을 만드는 시간까지 추가되어 결과적으로 응답 속도 마저 저하되기 때문에 사용자 경험에 악영향을 줄 수 있다.
## DB 접근 단계 feat. connection pool

1. **초기화**
   - 애플리케이션 시작 시 최소 및 최대 연결, 시간 초과 등과 같은 매개변수를 구성하여 커넥션 풀을 구성하고 초기화한다.
2. **연결 요청**
   - HTTP 요청에 따라 데이터베이스와 상호 작용해야 할 때 풀에 연결을 요청한다.
3. **연결 검색**
   - 풀은 사용 가능한 연결을 제공하거나 사용 가능한 연결이 없는 경우 새 연결을 생성 혹은 대기하여 이를 애플리케이션에 반환한다.
4. **데이터베이스 상호 작용**
   - 애플리케이션은 해당 연결을 사용하여 쿼리 또는 기타 데이터베이스 작업을 실행한다.
5. **연결 반환**
   - APP과 DB간 상호 작용이 종료되면 재사용을 위해 연결을 풀에 반환한다.

초기화 단계에서 진행되는 설정은 주로 APP에서의 요청으로 DB는 이에 맞게 연결을 준비하지만, 이는 상황에 따라 다르게 작용할 수 있다. 
특히 검색 단계에서 사용 가능한 연결이 없을 시 새로운 풀을 생성하도록 요구할 수 있지만 반대로 해당 클라이언트는 대기 상태로 전환 시키고 순차적으로 제공할 수도 있다. 한 마디로 쓰기 나름이다.

## 스프링부트의 커넥션 획득 방법

![](https://i.imgur.com/hminrwS.png)

자바에서는 커넥션 풀을 위해 `javax.sql.DataSource`라는 인터페이스를 제공하고 이 `DataSource`는 커넥션을 획득하는 방법을 추상화 하는 
인터페이스로써 커넥션 조회를 위한 핵심 기능을 제공한다.

[Java docs - DataSource](https://docs.oracle.com/en/java/javase/18/docs/api/java.sql/javax/sql/DataSource.html)

docs에서 제공하는 내용을 간단하게 요약하면 다음과 같다.
```
데이터 소스에 대한 연결을 위한 팩토리로 기존 DriverManager 기능의 대안으로 DataSource 객체는 연결을 얻는데 사용됩니다.
DataSource 인터페이스를 구현하는 객체는 일반적으로 JNDI(Java Naming and Directiory) API를 기반으로 하는 이름 지정 서비스에 등록됩니다.

구현은 총 세 가지 유형으로 기본 구현, 연결 풀링 구현, 분산 트랜잭션 구현이 있습니다.

기본 구현
표준 연결 객체를 생성합니다.

연결 풀링 구현
연결 풀링에 자동으로 참여할 연결 개체를 생성합니다.
(이 구현은 middle-tier connection pooling manager 와 함께 작동해야합니다.)

분산 트랜잭션 구현
분산 트랜잭션에 사용될 수 있고 대부분의(높은 확률로 항상) 연결 풀링에 참여하는 연결 개체를 생성합니다.
이 구현은 middle-tier transaction manager, connection pooling manager 와 함께 작동합니다.
(아닐 경우도 있지만 대부분의 경우 해당)

외에도 기본 생성자 필수, 수정할 수 있는 속성 등에 대한 추가 설명 ...
```

물론 개발자를 위해 `Apache의 Commons DBCP, Tomcat-JDBC, HikariCP` 등 다양한 `DBCP`는 `DataSource` 인터페이스를 이미 구현해 두었기 
때문에 세부 사항에 대해 신경쓰기 보단 `DBCP`에 직접 의존하는 코드가 아닌 `DataSource` 인터페이스에 의존하는 애플리케이션 로직 작성에 더욱 신경쓰는게 바람직하다. (참고로 스프링부트 2.0부터 기본적으로 HikariCP를 사용하고있다.)

