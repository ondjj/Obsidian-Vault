---
sticker: lucide//save
---
데이터베이스는 여러 응용 시스템들의 통합된 정보들을 저장하여 운영할 수 있는 공용 데이터를 구조화 해놓은 집합체이다.
같은 데이터가 서로 다른 목적을 가진 여러 응용 서비스에 중복되어 사용될 수 있다는 것이다.
# 사용 목적

데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였고 현재도 부분적으로 사용되고 있지만
기술이 발전함에 따라 서비스의 규모가 비대해지면서 상이한 시스템간 데이터를 공용으로 사용하기 시작했고 이에 따라 다양한 데이터를 효과적으로 관리할 수 있는 방법이 요구되었는데 이를 해소하기 위해 필연적으로 체계화된 데이터베이스가 등장하게되었다.

#### 데이터베이스의 특징

데이터베이스의 의미는 효율에 있다.

1.  **통합 데이터 - Integrated Data**
    여러가지 데이터를 통합하여 저장하는데 중복된 정보가 있다면 용량 낭비가 발생하기 때문에 데이터베이스는 중복된 정보에 대해 데이터를 통합하여 자료의 중복을 최소화한 데이터의 모임으로 구성한다.
    
2. **저장된 데이터 - Stored Data**
   사진 혹은 영상 파일을 하드디스크나 SSD


# 성능

데이터베이스의 성능 이슈는 디스크 I/O 를 어떻게 줄이느냐에서 시작된다. 디스크 I/O 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. 즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.

그렇기 때문에 순차 I/O 가 랜덤 I/O 보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O 이다. 랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.

# 데이터베이스 풀

## Connection Pool

클라이언트의 요청에 따라 어플리케이션에서 데이터베이스에 접근하기 위해서는 연결이 필요하고 요청에 따라 데이터베이스에 대한 연결을 생성하는 것은 비용적인 측면에서 리스크가 크기 때문에 사용량에 따라 적정량의 커넥션을 미리 생성해 놓고 유지 관리 및 삭제함으로써 리소스를 최적화 하고 관련된 오버헤드 비용을 줄일 필요가 있다.

![](https://i.imgur.com/C1hYRxX.png)


`Connection pool`은 이를 해결하기 위한 방법으로 연결을 여러 개 생성하고 공간(주로 캐시)에 저장해 이 공간의 Connection을 필요할 때 꺼내 쓰고 반환하는 기법을 말한다. 이는 풀의 기존 연결을 재사용함으로써 모든 요청에 대해 새 연결을 설정하는데 관련된 리소스 집약적인 프로세스를 최소화 하는데 효과적이다.(새로운 연결을 설정하는데 드는 비용에는 네트워크 대기 시간, 인증 및 리소스 할당 등이 포함된다.)

## DB 접근 단계
```
1. 애플리케이션 로직은 DB 드라이버를 통해 커넥션을 조회한다.
2. DB 드라이버는 DB와 TCP/IP 커넥션을 연결한다. 물론 이 과정에서 3 way handshake 같은 TCP/IP
연결을 위한 네트워크 동작이 발생한다.
3. DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW와 기타 부가정보를 DB에 전달한다.
4. DB는 ID, PW를 통해 내부 인증을 완료하고, 내부에 DB 세션을 생성한다.
5. DB는 커넥션 생성이 완료되었다는 응답을 보낸다.
6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.
```
이렇게 요청에 따라 그때 그때 커넥션을 만들게 된다면 DB는 물론, 애플리케이션 서버도 TCP/IP 커넥션을 새로 생성하기 때문에 불필요한 리소스 낭비를 유발하게 되고 자연스레 고객이 애플리케이션을 사용할 때 SQL을 실행하는 시간 뿐만 아니라 커넥션을 만드는 시간까지 추가되어 결과적으로 응답 속도 마저 저하되기 때문에 사용자 경험에 악영향을 줄 수 있다.
## DB 접근 단계 feat. connection pool

1. **초기화**
   - 애플리케이션 시작 시 최소 및 최대 연결, 시간 초과 등과 같은 매개변수를 구성하여 커넥션 풀을 구성하고 초기화한다.
2. **연결 요청**
   - HTTP 요청에 따라 데이터베이스와 상호 작용해야 할 때 풀에 연결을 요청한다.
3. **연결 검색**
   - 풀은 사용 가능한 연결을 제공하거나 사용 가능한 연결이 없는 경우 새 연결을 생성 혹은 대기하여 이를 애플리케이션에 반환한다.
4. **데이터베이스 상호 작용**
   - 애플리케이션은 해당 연결을 사용하여 쿼리 또는 기타 데이터베이스 작업을 실행한다.
5. **연결 반환**
   - APP과 DB간 상호 작용이 종료되면 재사용을 위해 연결을 풀에 반환한다.

초기화 단계에서 진행되는 설정은 주로 APP에서의 요청으로 DB는 이에 맞게 연결을 준비하지만, 이는 상황에 따라 다르게 작용할 수 있다. 
특히 검색 단계에서 사용 가능한 연결이 없을 시 새로운 풀을 생성하도록 요구할 수 있지만 반대로 해당 클라이언트는 대기 상태로 전환 시키고 순차적으로 제공할 수도 있다. 한 마디로 쓰기 나름이다.

## 스프링부트의 커넥션 획득 방법

![](https://i.imgur.com/hminrwS.png)

자바에서는 커넥션 풀을 위해 `javax.sql.DataSource`라는 인터페이스를 제공하고 이 `DataSource`는 커넥션을 획득하는 방법을 추상화 하는 
인터페이스로써 커넥션 조회를 위한 핵심 기능을 제공한다.

[Java docs - DataSource](https://docs.oracle.com/en/java/javase/18/docs/api/java.sql/javax/sql/DataSource.html)

docs에서 제공하는 내용을 간단하게 요약하면 다음과 같다.
```
데이터 소스에 대한 연결을 위한 팩토리로 기존 DriverManager 기능의 대안으로 DataSource 객체는 연결을 얻는데 사용됩니다.
DataSource 인터페이스를 구현하는 객체는 일반적으로 JNDI(Java Naming and Directiory) API를 기반으로 하는 이름 지정 서비스에 등록됩니다.

구현은 총 세 가지 유형으로 기본 구현, 연결 풀링 구현, 분산 트랜잭션 구현이 있습니다.

기본 구현
표준 연결 객체를 생성합니다.

연결 풀링 구현
연결 풀링에 자동으로 참여할 연결 개체를 생성합니다.
(이 구현은 middle-tier connection pooling manager 와 함께 작동해야합니다.)

분산 트랜잭션 구현
분산 트랜잭션에 사용될 수 있고 대부분의(높은 확률로 항상) 연결 풀링에 참여하는 연결 개체를 생성합니다.
이 구현은 middle-tier transaction manager, connection pooling manager 와 함께 작동합니다.
(아닐 경우도 있지만 대부분의 경우 해당)

외에도 기본 생성자 필수, 수정할 수 있는 속성 등에 대한 추가 설명 ...
```

물론 개발자를 위해 `Apache의 Commons DBCP, Tomcat-JDBC, HikariCP` 등 다양한 `DBCP`는 `DataSource` 인터페이스를 이미 구현해 두었기 
때문에 세부 사항에 대해 신경쓰기 보단 `DBCP`에 직접 의존하는 코드가 아닌 `DataSource` 인터페이스에 의존하는 애플리케이션 로직 작성에 더욱 신경쓰는게 바람직하다. (참고로 스프링부트 2.0부터 기본적으로 HikariCP를 사용하고있다.)

## WAS의 Thread와 Connection Pool 관리

WAS에서 설정해야 하는 값 중 성능에 가장 큰 영향을 주는 부분은 Thread와 Connection Pool의 개수이다.
이 값은 직접적으로 메모리와 관련이 되어 있기 때문에 많이 사용할 수록 메모리를 많이 점유하게 되지만 이를 방지하기 위해 연결의 개수를 적게 지정한다면 많은 요청이 들어올 경우 처리하지 못 하고 대기할 수 밖에 없게 된다.

대표적으로 다음과 같은 경우 적절한 조치가 필요하다 판단할 수 있다.
- DB Connection Pool의 개수가 지나치게 많을 경우
- WAS Thread 수가 DB Connection Pool의 개수보다 적게 설정 되어 있는 경우

커넥션 풀의 개수가 적을 경우 발생하는 문제에 대해선 이제까지 언급한 바와 같은데 WAS의 Thread 수가 커넥션 풀보다 많아야 하는 이유는 무엇일까?

일반적인 시나리오에서 이 개념은 동시 요청의 효율적인 처리를 보장하는데 의미가 있다.

1. 동시성 처리 : WAS의 스레드 수가 많을수록 클라이언트에서 동시에 들어오는 요청을 더 많이 처리할 수 있다.
   (클라이언트의 요청 수가 사용 가능한 스레드를 초과하는 경우 일부 요청은 대기열에 머물러야 하므로 잠재적인 지연이나 시간 초과가 발생할 수 있다.)
2. 리소스 균형 조정 : WAS에서 DB의 커넥션 풀 수보다 더 많은 스레드를 가짐으로써 클라이언트 요청 관리와 데이터베이스 용량 간의 균형을 유지하여 데이터베이스의 리소스 고갈이나 경합을 방지할 수 있다.

이렇게 스레드 수를 적절히 설정하는 것으로 과도한 연결로 인한 데이터베이스의 부하를 방지할 수 있고 WAS가 더 많은 클라이언트 요청을 처리할 수 있도록 하여 병목 현상을 방지하고 보다 원활한 작업 흐름을 보장한다.

물론 애플리케이션에 대한 모든 요청이 DB에 접근하는 것은 아니라는 가정하에 이루어지는 조건이기 때문에 여전히 적절한 스레드와 커넥션 풀의 개수를 찾는것이 포인트인데, 이를 해결하기 위한 가장 효과적인 방법은 애플리케이션을 실제 운영할 시스템 환경에서 성능 테스트를 진행하는 것으로 시스템 환경에 최적화된 값을 찾아 내는 것이 주요하다.

예를 들어 커넥션 풀을 보통 40-50개로 지정한다면 스레드는 이보다 10개 정도 더 지정하는 것으로 균형을 유지할 수 있다.

### Thread Pool

Connection pool과 비슷한 맥락으로 Thread pool이라는 개념도 존재한다.
이 역시 매 요청마다 요청을 처리할 Thread를 만드는것이 아닌, 미리 생성한 pool 내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법이다.

