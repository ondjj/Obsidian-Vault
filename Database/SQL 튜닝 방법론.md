---
sticker: lucide//list-ordered
---
# 온라인 SQL과 배치 SQL

온라인 SQL과 대규모 배치 SQL은 시기, 범위, 실행 특성에 따라 SQL 쿼리를 실행하는 다양한 방법을 나타내는 방식을 말한다.

### 온라인 SQL

이는 일반적으로 즉각적인 사용자 요청이나 진행 중인 시스템간 상호 작용에 대한 응답으로 실시간으로 실행되는 SQL 쿼리 작업을 의미한다.
온라인 SQL 쿼리는 사용자가 상호 작용을 기반으로 즉각적인 피드백이나 데이터 검색을 기대하는 웹 애플리케이션과 같이 사용자 작업에 대한 빠른 응답이 필요한 앱 또는 시스템과 관련되는 경우가 많기 때문에 이와 관련된 쿼리는 요청 시 필요한 특정 데이터 검색, 업데이트 또는 삽입을 포함하며 규모가 작은 편에 속한다. 이런 특성으로 온라인 SQL은 원활한 사용자 경험을 보장하기 위해 짧은 대기 시간과 응답성에 최적화되어야 한다.

### 대규모 배치 SQL

대규모 배치 SQL 작업은 일반적으로 상당한 양의 데이터를 처리하는 대규모 SQL 쿼리 실행을 이야기 한다.
이런 유형의 SQL은 데이터 마이그레이션, 데이터 웨어하우징 작업 또는 대규모 데이터 세트와 관련된 분석과 같은 대량 작업을 수행하는데 사용 되기 때문에
배치 SQL 쿼리에는 여러 테이블이나 데이터베이스에 걸친 복잡한 집계, 조인 또는 변환이 포함되는 경우가 많다. 관련된 데이터의 양이 많기 때문에 실행하는데 시간이 오래 걸릴 수 있으며 최적화는 효율적인 리소스 활용, 병렬 처리 및 전체 실행 시간 최소화에 초점을 맞추는 경우가 많다.

결과적으로 온라인 SQL은 즉각적인 사용자 상호 작용과 소규모 작업에 맞춰져 있는 반면  배치 SQL은 상당량의 데이터 볼륨을 처리하고 배치 프로세스에 자주 사용되므로 주요한 차이점은 SQL 쿼리의 규모, 목적 및 타이밍에 있다고 할 수 있다.

# 온라인 Select문 튜닝 방법론

## 1. 적절한 인덱스를 사용하여 Block I/O를 최소화 하라

조인이 없는 경우는 적절한 인덱스를 사용하는것 만으로도 상당한 효과를 볼 수 있다. 조인이 있는 경우 특히 Driving(선행) 집합에 신경 써야 한다.
왜냐하면 Nested Loop 조인을 사용했고, 선행 집합의 건수가 많다면, 후행 집합의 조인의 시도 횟 수가 증가하므로 성능이 느려지기 때문이다.
따라서 적절한 인덱스를 이용하여 선행 집합의 건수를 줄인다면, 혹은 가장 적은 집합을 선행으로 놓는다면, 후행 집합으로의 조인 건수는 줄어든다.
물론 이때에도 후행 집합의 적절한 인덱스는 필수 조건으로 Driving 집합의 Block I/O를 줄이기 위해 최적화된 인덱스가 없다면 생성하고, 있다면 그것을 사용해 최적의 Access Path를 만들어야한다.

> [!NOTE] 조인 작업 및 중첩 루프 조인
> 본질적으로 조인 시도 횟 수는 실제로 조인할 행 수에 따라 일정하게 유지 되지만 성능에 미치는 영향은 선행 세트의 크기에 따라 다르게 나타난다. 선행 세트의 크기가 클 수록 더 많은 반복이 발생하고 리소스 소비가 증가하며 잠재적으로 성능 저하를 일으키게 되는 요인이 된다.


DBMS는 쿼리를 파싱하고, 해당 쿼리를 수행하기 위한 최적의 방법을 선택하는 기능이 내장되어있다. MySQL은 엔진 내에서 SQL optimizer가 이 역할을 담당한다. 다양한 알고리즘들이 있지만 MySQL은 Nested Loop와 그 파생 알고리즘만을 지원한다고 한다.(8.0.18부터 hash join도 지원한다.) 


![](https://i.imgur.com/0BksjP7.png)

Nested Loop 는 이름에서 알 수 있듯 중첩 루프 구조를 가지고 있다. A 테이블의 레코드 하나 하나에 대해 B 테이블의 레코드를 스캔하고, 조인 조건에 맞는 레코드를 리턴한다. 테이블의 레코드 수를 R(테이블)이라고 한다면 `R(A) * R(B)`를 소요하는 것이다.
선행 집합의 수와 후행 집합의 수에 무관하게 총 조인 횟수는  `R(A) * R(B)` 만큼의 연산을 수행함에도 선행 테이블(Driving Table)의 선택이 중요한데,
이는 반복이 미치는 영향과 리소스 활용, 조인 성능과 연결된다. 위에서도 언급 했듯이 총 반복 횟수가 일정하게 유지되더라도 선행 집합의 크기는 반복 프로세스가 발생해야하는 횟수에 영향을 미친다. 선행 테이블이 작을수록 반복 횟수가 줄어들어 조인 프로세스가 더 빠르고 효율적으로 동작하는것이다.
또한 이전 세트가 클수록 더 많은 리소스가 필요하다. 선행 집합이 큰 경우 엔진은 후행 집합의 각 레코드에 대해 이를 반복해야하고, 이로 인해 리소스 소비가 증하여 처리 시간이 길어지게 된다.

선행 테이블의 선택은 조인 작업에 전반적인 성능에 영향을 준다. 조인 시도 횟수는 일정하게 유지되지만 더 작고 잘 인덱싱된 선행 집합을 선택하면 개별 조인 시도의 효율성과 속도가 크게 향상되어 전반적인 성능이 향상될 수 있다. 따라서 총 반복 횟수는 고정되어 있지만 리소스 활용도를 최적화 하고 인덱스를 효과적으로 활용하며 중첩 루프 구조 내에서 개별 조인 시도의 효율성을 향상 시키려면 최적의 선행 집합을 선택하는 것이 중요하다고 할 수 있다.

단순히 중첩 반복을 통해 동작하지만, 최적화를 하기 위해  BKA(Batched Key Access), BNL(Block Nested Loop)과 같은 방식들이 사용되고 있다. 또한 기본적으로는 index를 활용하는 방법도 있다. 기본적으로 Driving Table의 각 레코드 마다 조인 조건에 부합하는 레코드를 찾아낼 때 INDEX를 사용할 수 있돌