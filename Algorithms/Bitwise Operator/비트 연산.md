
**HDD**
![](https://velog.velcdn.com/images/ondj/post/1837c36e-3b03-40e5-96df-19b809f0f43b/image.png)


어떤 데이터든 컴퓨터에 저장될 때는 모두 0과 1로 저장된다.
하드 디스크 표면은 자성체로 뒤덮여 바늘 끝의 코일로 자성체의 N극과 S극을 읽을수도 있고 그 방향을 바꿀수도 있는데 한 번 방향을 바꾸면 다시 돌아가지 않기 때문에 정보가 기억되는것이다.

이 때 바늘이 디스크 표면의 자기장을 일정한 간격을 지나가는동안 읽다가 자기장의 극성이 변하면 1 그대로면 0으로 인식한다.

**CD**
![](https://velog.velcdn.com/images/ondj/post/ff0cdb85-8e3d-42bb-a34c-f591a8aa284a/image.png)

CD나 DVD는 매끄러운 표면에 레이저를 발사해 만든 스크래치로 정보를 저장하고 빛을 쏴 굴곡을 읽어내는 형태이고 그 길이가 짧으면 0 길면 1로 식별한다.


---

# 비트 공간

**프로그래밍 언어**

![](https://velog.velcdn.com/images/ondj/post/bc14f58f-33af-4d56-8775-6c163b32a5b1/image.png)

정수를 컴퓨터에 저장하면 비트로 저장이 되는데, 자바에서는 Integer가 4byte로 1byte는 8bit로 구성되기 때문에 총 32개의 공간에 정보가 담기게된다.

```
4byte = 32bit
```

정수 8을 4byte 공간에 표현한다면 다음과 같이 0과 1을 나열할 수 있는것이다.

![](https://velog.velcdn.com/images/ondj/post/b4aed737-1013-41f1-9af7-42d02e4e5fbf/image.png)

비트 하나 당 0과 1로 저장할 수 있고 이 때 공간이 32개가 있으면 표현할 수 있는 최대 값은 `2^32`에 해당하는 숫자를 표현할 수 있지만 비트 공간의 숫자는 0부터 시작하기 때문에 표현할 수 있는 최대 숫자의 크기는 `2^32 - 1` 이 되고 양의 정수와 음의 정수를 표현하기 위해 공간의 맨 앞의 한 칸은 기호 사인의 역할로 사용된다. 
(양수일 경우 `0` 음수일 경우 `1`로 표현된다.)

![](https://velog.velcdn.com/images/ondj/post/d78dee16-5b80-4cfd-8b0a-3f3ab54c17ed/image.png)

그렇기 때문에 양수일 경우 사용할 수 있는 비트 공간이 하나 더 줄어들어 
`2^31 - 1`만큼의 숫자를 표현할 수 있고 음의 정수일 경우 양수로 표현을 하기 때문에 다음과 같이 표현할 수 있다. `-2^31`

이를 비트 공간의 표현을 통해 알아보자

![](https://velog.velcdn.com/images/ondj/post/f23a5097-3b73-41af-a744-c485e192421d/image.png)

양의 정수는 부호 사인을 0으로 고정하고 이진수를 정수로 변환하면 바로 값을 알아낼 수 있다. 예를 들어 모든 부호 사인을 제외한 모든 공간이 0이라면 양수에서는 이 값이 표현할 수 있는 가장 작은 정수 `0`이지만 음의 정수에서 가장 작은 값을 표현하면 `0`이 아닌 표현할 수 있는 가장 작은 값, 예시에서는 `-8`의 값을 가지게 된다.

```
4byte의 정수 공간을 정수 범위로 표현하면 
-2,147,483,648 ~ 2,147,483,647의 범위를 갖는다.
만약 이보다 더 큰 값을 표현한다면 int 타입보다 더 큰 자료형을 사용해야한다.
```
---

# 비트 연산의 장점
비트 연산은 한정된 메모리에서 On/Off의 데이터를 저장할 수 있다.
일반적으로 On/Off, flag 처리를 하는데 자바에서 사용하는 boolean 자료형은 1바이트를 소모하고 1바이트는 8비트이기 때문에 만약 비트연산자를 이용하기로 했다면, 8개의 flag를 저장할 수 있어 자료를 효율적으로 저장할 수 있다.

추가로 비트 연산은 곱하기와 나누기 연산을 빠르게 수행할 수 있다. 기본적으로 비트 쉬프트를 하면 2를 곱하거나 2를 나눈 연산의 결과가 나오는데 
`13*9`를 연산하면 CPU는 13을 더하는 연산 과정과 카운터를 1씩 증가 시키는 연산을 각 9번씩 진행하지만 이를 쉬프트 연산으로 진행하면

`13*9`는 왼쪽으로 3번 쉬프트하고 13을 한번 더하는걸로 연산을 수행할 수 있고 이는 일반적인 곱셈보다 더 빠른 연산을 하면서 횟 수 역시 줄인 결과를 가져오기 때문에 제한된 시스템에서는 시간과 비용을 절약할 수 있는 방법이다.
```
`0001`을 왼쪽으로 쉬프트 연산을 한 번 수행하면 곧 바로 `0010`로 변환되고 
십진수를 기준으로 2를 곱한것과 같은 결과를 얻을 수 있다.
```

---

# 연산의 종류

**AND**
![](https://velog.velcdn.com/images/ondj/post/6bc671c1-045e-4517-955f-ee46a07e7b0d/image.png)
```
& 연산(논리곱)은 2진수로 표현된 2개의 피연산자를 AND연산 하여 결과를 나타낸다.
AND 연산자는 2진수로 표현된 두 비트가 모두 1일 때만 1을 반환하며,
다른 경우는 모두 0을 반환한다.
```

**OR**
![](https://velog.velcdn.com/images/ondj/post/a3706256-c93b-4a31-915a-21dbac8014c5/image.png)
```
| 연산(논리합)은 2진수로 표현된 2개의 피연산자를 OR연산 하여 결과를 나타낸다.
OR 연산자는 대응되는 두 비트 중 하나라도 1이면 1을 반환하며, 
두 비트가 모두 0일 때만 0을 반환한다
```

**XOR**
![](https://velog.velcdn.com/images/ondj/post/c7838ec2-76a7-4128-a15e-a9062d4efbb7/image.png)
```
^ 연산(배타적 논리합)은 2진수로 표현된 2개의 피연산자를 XOR연산 하여 결과를 나타낸다.
XOR 연산자는 대응되는 두 비트가 서로 다르면 1을 반환하고, 서로 같으면 0을 반환한다.

```

**NOT**
![](https://velog.velcdn.com/images/ondj/post/b3166ae4-16a8-484f-86d3-6310d68cd236/image.png)
```
^연산(배타적 논리합)은 2진수로 표현된 2개의 피연산자를 XOR연산 하여 결과를 나타낸다.
XOR 연산자는 대응되는 두 비트가 서로 다르면 1을 반환하고, 서로 같으면 0을 반환한다. 
```

```java
 System.out.println(" 15 & 25 = " + (15 % 25));
 System.out.println(" 15 | 25 = " + (15 | 25));
 System.out.println(" 15 ^ 25 = " + (15 ^ 25));
 System.out.println(" ~25 = " + (~25)); 

 15 & 25 = 9
 15 | 25 = 31
 15 ^ 25 = 22
 ~25 = -26
 ```
 
 ---
 
#  Shift 연산

### **Left Shift 연산자**

`연산 기호 : << `

![](https://velog.velcdn.com/images/ondj/post/49fa8558-962e-4491-a14f-7439fb569ded/image.png)

Shift 연산은 진행 방향이 중요하다. 이미지와 같이 화살표의 방향이 왼쪽을 향한다면 숫자만큼 왼쪽으로 밀고 `0`으로 빈 공간을 채워 연산을 진행할 수 있다. 


--- 
### **Right Shift 연산**

`연산 기호 : >>`	
![](https://velog.velcdn.com/images/ondj/post/e80fc792-4376-4cc6-ab62-0eed5ad46d09/image.png)
비트값을 주어진 숫자만큼 오른쪽으로 이동시키고 그만큼 맨 뒤부터 데이터가 사라진다.

![](https://velog.velcdn.com/images/ondj/post/2fb0cf8c-0906-47a4-b7de-669fbc7aadb8/image.png)

`Right Shift`연산은 `arithmetic right shift`연산이라고도 불리는데, 정수의 부호라는 수학적인 관계를 염두해두고 사용하는 연산이기 때문이다.
만약 음수인 상태로 이 연산을 계속 진행한다면 결국 모든 비트가 `1`이 되고 결과적으로 `-1`의 값을 가지게된다.

## Logical Right Shift
`Logical Right Shift 연산`은 사인 비트를 무시하고 무조건 Shift하는 연산으로 이 연산자를 가지고 계속해서 Shift를 진행하면 결국 모든 비트가 `0`으로 채워지게된다.
(연산 기호는 `>>>` 꺽쇠 세 개로 표현한다.)

![](https://velog.velcdn.com/images/ondj/post/b31c6441-1bc6-41f2-86b5-34f319deb07f/image.png)


---


**참고 사이트**

[엔지니어대한민국](https://www.youtube.com/@eleanorlim/playlists)
[해시넷](http://wiki.hash.kr/index.php/%EC%8B%9C%ED%94%84%ED%8A%B8%EC%97%B0%EC%82%B0%EC%9E%90)
[수길쌤의 IT](https://blog.naver.com/liveforu/221955373677)