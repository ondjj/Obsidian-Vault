---
sticker: lucide//eraser
---
## 개요

리프 노드의 수는 BST와 B-Tree를 구별하는 주요 차이점 중 하나로 BST는 두 개로 고정이되는 반면, B-Tree는 차 수에 따라 말단 노드의 개 수가 결정된다. 

만약 데이터를 삽입하는 과정을 갖는다면 항상 리프 노드에서 발생하게 되는데 이는 삭제하는 과정 역시 동일하지만 삽입을 통해 자녀 노드의 수가 기준 값 보다 커졌을 경우 승진을 통한 재조정이 발생하지만 삭제의 경우 key의 개수가 최소 key의 수보다 적어졌다면  재조정이 이루어지게된다.

```
B-Tree에 저장되는 데이터가 있다면 이 데이터 각각은 Key를 통해 동작하지만 여기선 데이터가 Key의 역할까지 수행하기 때문에 두 단어를 혼용해서 사용한다.
```

## 삭제 과정

다음과 같은 3차 B-Tree가 존재한다고 했을때, 데이터 삭제 과정에서의 재조정 과정을 살펴보자

먼저 6이라는 데이터를 삭제한다면 아래와 같은 흐름으로 동작하게 된다.

![](https://i.imgur.com/IE2cfN8.png)

- 데이터 15와 6을 비교하고 6은 15보다 작기 때문에 왼쪽으로 이동한다.
- 3과 6을 비교한다. 6은 3보다 크기 때문에 오른쪽으로 이동하지만, 7이라는 같은 레벨의 노드가 존재하기 때문에 7과 6을 비교하게되고, 7은 6보다 크기 때문에 3과 7사이 범위를 갖는 리프 노드로 이동한다.
- 5와 대소 비교를 하고 타겟 데이터를 발견하면 삭제가 이루어진다.

위와 동일한 과정을 통해 5라는 데이터를 삭제하게 되면 기존 트리는 아래와 같이 비어있는 리프 노드를 갖게 되고, 이는 3차 B-Tree가 가지는 각 노드의 최소 key수 1개 보다 작기 때문에 재조정이 필요하다.

![[스크린샷 2024-01-17 오전 9.16.49.png]]

## 데이터 재조정

B-Tree에서 데이터 삭제를 통해 재조정이 필요하다면 총 세 가지 방법을 통해 재조정 할 수 있다.

#### 1. key 수가 여유있는 형제의 지원을 받는다.

가장 간단한 방법으로 예시의 3차 B-Tree의 경우 5와 6을 삭제했지만, 같은 레벨의 노드의 데이터가 충분한 상태이기 때문에 이를 끌어와 트리 구조를 유지할 수 있다.

#### 2. 부모의 지원을 받고 형제와 합친다.

만약 1번의 방법을 사용할 수 없다면 부모 노드의 데이터를 받고 동일 레벨의 노드와 합치는 과정을 통해 재조정 할 수 있다.

#### 3. 부모의 지원을 받은 후 문제가 발생한다면 그 곳에서 다시 재조정한다.

이 경우 부모 노드에 해당하게 되는데, 만약 부모 노드의 지원을 통해 리프 노드의 문제가 해결
