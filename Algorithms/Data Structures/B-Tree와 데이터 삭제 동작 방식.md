---
sticker: lucide//eraser
---
## 개요

리프 노드의 수는 BST와 B-Tree를 구별하는 주요 차이점 중 하나로 BST는 두 개로 고정이되는 반면, B-Tree는 차 수에 따라 말단 노드의 개 수가 결정된다. 

만약 데이터를 삽입하는 과정을 갖는다면 항상 리프 노드에서 발생하게 되는데 이는 삭제하는 과정 역시 동일하지만 삽입을 통해 자녀 노드의 수가 기준 값 보다 커졌을 경우 승진을 통한 재조정이 발생하지만 삭제의 경우 key의 개수가 최소 key의 수보다 적어졌다면  재조정이 이루어지게된다.

```
B-Tree에 저장되는 데이터가 있다면 이 데이터 각각은 Key를 통해 동작하지만 여기선 데이터가 Key의 역할까지 수행하기 때문에 두 단어를 혼용해서 사용한다.
```

## 삭제 과정

다음과 같은 3차 B-Tree가 존재한다고 했을때, 데이터 삭제 과정에서의 재조정 과정을 살펴보자

먼저 6이라는 데이터를 삭제한다면 아래와 같은 흐름으로 동작하게 된다.

![](https://i.imgur.com/IE2cfN8.png)

- 데이터 15와 6을 비교하고 6은 15보다 작기 때문에 왼쪽으로 이동한다.
- 3과 6을 비교한다. 6은 3보다 크기 때문에 오른쪽으로 이동하지만, 7이라는 같은 레벨의 노드가 존재하기 때문에 7과 6을 비교하게되고, 7은 6보다 크기 때문에 3과 7사이 범위를 갖는 리프 노드로 이동한다.
- 5와 대소 비교를 하고 타겟 데이터를 발견하면 삭제가 이루어진다.

위와 동일한 과정을 통해 5라는 데이터를 삭제하게 되면 기존 트리는 아래와 같이 비어있는 리프 노드를 갖게 되고, 이는 3차 B-Tree가 가지는 각 노드의 최소 key수 1개 보다 작기 때문에 재조정이 필요하다.

![[스크린샷 2024-01-17 오전 9.16.49.png]]

## 데이터 재조정

B-Tree에서 데이터 삭제를 통해 재조정이 필요하다면 총 세 가지 방법을 통해 재조정 할 수 있다.

#### 1. key 수가 여유있는 형제의 지원을 받는다.

가장 간단한 방법으로 예시의 3차 B-Tree의 경우 5와 6을 삭제했지만, 같은 레벨의 노드의 데이터가 충분한 상태이기 때문에 형제 노드의 도움을 받아 트리 구조를 유지할 수 있다.

주의할 점은 B-Tree의 규칙을 준수하면서 데이터의 이동이 이루어져야 한다는 것인데 그 규칙은 다음과 같다.

![](https://i.imgur.com/rgSECoY.png)

삭제된 노드를 기준으로 왼쪽을 동생 노드, 오른쪽을 형 노드라고 한다면, 우선 동생 노드의 데이터가 충분한지 확인하고 충분하다면 동생 노드의 지원을, 아니라면 형 노드를 확인한다.

이후 곧 바로 동생 노드의 데이터 2를 옮겨오면 될 것 같지만, B-Tree의 데이터 흐름상 곧 바로 데이터를 옮기게 된다면 오름 차순 정렬이라는 규칙을 준수하지 못 하기 때문에 부모 노드의 도움을 받아 재조정이 이루어진다.

![](https://i.imgur.com/LjB5xqp.png)

총 세 개의 노드에 변화가 발생했고, 각 노드가 최소 key 수를 만족한다면 데이터 5에 대한 삭제가 완료 된다.

만약 동생 노드에게 도움을 받을 수 없는 상황이라면 형 노드의 도움을 받을 수 있는지 확인하고, 위와 동일한 과정을 거쳐 트리 구조를 유지한다.

![](https://i.imgur.com/Cd7thHh.png)

#### 2. 부모의 지원을 받고 형제와 합친다.

만약 1번의 방법을 사용할 수 없다면 부모 노드의 데이터를 받고 동일 레벨의 노드와 합치는 과정을 통해 재조정 할 수 있다.

![](https://i.imgur.com/chTyqWi.png)

데이터 7을 삭제하게 된다면, 해당 노드는 비어있는 상태로 이루지고, 이에따라 최소 key 수를 만족할 수 없는데 형제 노드 역시 데이터가 각각 한 개로 도움을 줄 수 없는 상태이다.

이 경우 우선 부모 노드의 왼쪽 데이터를 받고, 동생 노드와 합치는 것으로 재조정이 이루어진다.
(정렬 조건에 따라 부모 노드의 오른쪽 데이터는 왼쪽으로 이동한다.)

![](https://i.imgur.com/Re3Ad4Q.png)

이 방법은 데이터를 삽입하는 과정에서 발생할 수 있는 승진(분할)의 역순이라고 볼 수 있다.

#### 3. 부모의 지원을 받은 후 문제가 발생한다면 그 곳에서 다시 재조정한다.

이 경우 부모 노드에 해당하게 되는데, 부모 노드의 지원을 통해 리프 노드의 문제가 해결되었지만 역으로 부모 노드에 문제가 발생하게되는 경우이다. 

데이터 1과 2가 삭제된 상황을 예시로 본다면, 1과 2는 동일한 리프 노드에 존재고 있어 해당 노드는 비어있는 상태가 되고 형제 노드의 도움을 받을 수 없기 때문에 2번 방법을 통해 부모 노드의 지원을 받는다면 아래와 같은 구조를 가지게 된다.

![](https://i.imgur.com/phd6USV.png)

부모 노드의 지원을 통해 리프 노드의 문제는 해결이 되었지만 이 구조는 밸런스 트리인 B-Tree와 맞지 않고, 최소 key 개수 또한 만족하지 못한다.

