---
sticker: lucide//user-check
tags: JVM
Bit-of-History: ""
---
## 목차

1. [A Bit of History](#A-Bit-of-History)
2. [Organization of the Specification](#Organization-of-the-Specification)
3. [Notation](#Notation)
4. [Feedback](#Feedback)


# 1.1 A Bit of History

Java 프로그래밍 언어는 범용, 동시성, 객체 지향을 지원하는 언어로 그 문법은 C와 C++과 유사하지만 C 및 C++을 복잡하고 혼란스럽게 만드는 많은 기능을 제거하고 안전성을 갖추고 있습니다.

자바 플랫폼은 네트워크 연결된 networked consumer devices에 소프트웨어를 개발하는 문제를 해결하기 위해 개발되었는데 이를 위해 여러 호스트 아키텍처를 지원하고 소프트웨어 구성 요소를 안전하게 전달할 수 있도록 설계되었습니다.
초기 목적을 충족하기 위해 컴파일된 코드는 네트워크를 통해 전송되어야하며 모든 클라이언트에서 작동하고 클라이언트에게 실행이 안전함을 보장해야 했습니다.

World Wide Web의 대중화는 자바의 이러한 속성들을 훨씬 더 흥미롭게 만들었습니다. 웹 브라우저는 수백만 명의 사람들이 간단한 방법으로 인터넷을 서핑하고 미디어가 풍부한 콘텐츠에 접근할 수 있게 해주었습니다. 
결국 여러분이 보고 듣는 것은 여러분이 사용하는 머신이 빠른 네트워크에 연결되었는지 느린 모뎀에 연결되었는지에 관계없이 본질적으로 동일한 매체가 되었습니다.

웹 애호가들은 곧 웹의 HTML 문서 형식에서 지원하는 내용이 너무 제한적이라는 것을 발견했고
**forms**과 같은 HTML 확장자는 그러한 제한만을 강조했을 뿐이며, 어떤 브라우저도 사용자가 원하는 모든 기능을 포함할 수 없다는 것을 명시 했습니다. 확장성이 해답이었습니다.

HotJava 브라우저는 HTML 페이지 안에 프로그램을 내장하는 것을 가능하게 함으로써 자바 프로그래밍 언어와 플랫폼의 흥미로운 특성을 처음으로 보여주었습니다. 

- 프로그램은 프로그램이 나타나는 HTML 페이지와 함께 브라우저에 투명하게 다운로드됩니다. 
- 브라우저에 의해 받아들여지기 전에, 프로그램이 안전한지를 확인하기 위해 신중하게 점검됩니다. 
- HTML 페이지처럼, 컴파일된 프로그램은 네트워크와 호스트에 독립적입니다. 
- 프로그램은 어디에서 왔는지 또는 어떤 종류의 컴퓨터에 로드되고 실행되는지에 관계없이 동일하게 동작합니다.

자바 플랫폼을 포함하는 웹 브라우저는 더 이상 미리 작성된 기능들에 제한되지 않습니다. 
동적인 콘텐츠를 포함하는 웹 페이지의 방문자는 해당 콘텐츠로 인해 컴퓨터가 손상되지 않는다는 것을 보장받을 수 있습니다. 프로그래머는 프로그램을 한 번 작성하며, 프로그램은 자바 런타임 환경을 제공하는 모든 컴퓨터에서 실행됩니다.


# 1.2 The Java Virtual Machine

Java Virtual Machine은 자바 플랫폼의 초석으로, 하드웨어와 운영체제의 독립성, 컴파일된 코드의 작은 크기, 악성 프로그램으로부터 사용자를 보호하는 기능 등을 담당하는 기술의 구성요소입니다.

JVM은 추상적인 컴퓨팅 머신으로 실제 컴퓨팅 머신처럼 명령어 세트를 가지고 있고 런타임에 다양한 메모리 영역을 조작합니다. 가상 머신을 이용하여 프로그래밍 언어를 구현하는 것이 비교적 일반적인데 가장 잘 알려진 머신은 USCD 파스칼의 P-Code 머신입니다.

Sun Microsystems 에서 시작된 JVM의 첫 번째 프로토타입 구현은 현 시대의 PDA(Personal Digital Assistant)와 유사한 `handheld device`가 호스팅하는 소프트웨어에서 JVM 명령어 셋을 모방했습니다.

현재 오라클은 모바일, 데스크톱, 서버 장치에서 JVM을 에뮬레이트하지만 자바 가상 머신은 특정 구현 기술이나 호스트 하드웨어, 호스트 운영 체제를 가정하지 않습니다. 본질적으로 해석되는 것이 아니라 명령어 셋을 silicon CPU의 명령어 셋으로 컴파일 하여 구현할 수도 있고 microcode로 구현하거나 또는 silicon으로 구현할 수도 있습니다.

JVM은 Java 프로그래밍 언어에 대해 아무것도 알지 못하지만 특정 이진 형식, 클래스 파일 형식에 대해 알고 있습니다. 클래스 파일에는 JVM 명령(또는 바이트 코드)과 기호 테이블 및 기타 보조 정보가 포함됩니다.

보안을 위해 JVM은 클래스 파일의 코드에 강력한 구문 및 구조적 제약을 부과합니다. 그러나 유효한 클래스 파일로 표현될 수 있는 기능을 가진 언어는 JVM에 호스팅할 수 있습니다. 일반적으로 사용 가능한 독립적인 플랫폼을 사용하고자한다면 다른 언어의 개발자는 자신의 언어를 전달하는 수단으로 JVM을 사용할 수 있습니다.

> [!info]
> 여기서 말하는 JVM은 java SE 17 플랫폼을 기준으로 설명합니다.
> 
> 

> [!NOTE]
> Oracle이 모바일, 데스크톱 및 서버 장치에서 JVM(Java Virtual Machine)을 에뮬레이트한다는것은 위와 같은 장치에서 Java 애플리케이션을 실행하고 Java 코드를 실행할 수 있는 방법을 제공한다는 것을 의미한다.
> 
> JVM은 Java 플랫폼의 중요한 구성 요소로 Java 바이트 코드를 수정하지 않고 다양한 플랫폼에서 실행할 수 있도록 해준다. JVM은 바이트 코드를 기계별 코드로 변환하여 Java를 플랫폼 독립적인 언어로 만들어준다.
> 
> **에뮬레이트:**
> JVM을 에뮬레이트한다는 것은 JVM의 소프트웨어 기반 구현을 만들어 다양한 하드웨어 및 운영 체제에서 실행할 수 있도록 하는 것을 의미한다. 물리적 하드웨어 구현에 의존하는 대신 소프트웨어에서 에뮬레이션하는 것은 다양한 기기 및 아키텍처에서 Java 애플리케이션을 실행할 수 있게 한다.
> 
> Oracle이 다양한 장치에서 JVM을 에뮬레이트하면 Java 애플리케이션을 일관되고 안정적으로 실행할 수 있도록 보장할 수 있다. 이는 개발자가 Java 코드를 한 번 작성하면 Oracle이 제공하는 JVM 에뮬레이션 덕분에 다양한 플랫폼에서 수정 없이 실행될 수 있음을 의미하며, 이는 Java 프로그래밍 언어와 플랫폼의 주요 기능 중 하나로서 다양한 유형의 장치와 환경에서 소프트웨어를 개발하는 데 인기 있는 이유 중 하나이다.




# 1.3 Organization of the Specification

- Chapter 2 : JVM 아키텍처에 대해 간략히 설명합니다.
  
- Chapter 3 : 자바 프로그래밍 언어로 작성된 코드를 자바 JVM의 명령어로 컴파일하는 방법을 소개합니다.
  
- Chapter 4 : 클래스 파일 형식, 컴파일된 클래스와 인터페이스를 나타내기 위해 사용되는 하드웨어와 운영 체제에 독립적인 이진 형식을 지정합니다.
  
- Chapter 5 : JVM의 시작과 클래스 및 인터페이스 로드, 링크 및 초기화에 대해 설명합니다.
  
- Chapter 6 : JVM의 명령어 셋을 명시하며 명령어를 opcode 니모닉의 알파벳 순서로 제시합니다.
  
- Chapter 7 : opcode 값으로 색인화된 JVM opcode memonics 표를 제공합니다.

> [!info] 
> Java® Virtual Machine Specification 2판에서 2장은 Java Virtual Machine 사양을 지원하기 위한 Java 프로그래밍 언어에 대한 개요를 제공했습니다. 
> 
> Java Virtual Machine Specification, Java SE 17 Edition에서 독자는 Java 프로그래밍 언어에 대한 정보를 얻기 위해 Java Language Specification, Java SE 17 Edition을 참조합니다. 형식의 참조: (JLS §x.y)가 필요한 위치를 나타냅니다.

> [!info] 
> Java® Virtual Machine Specification 2판에서 8장은 Java Virtual Machine 스레드와 공유 메인 메모리의 상호 작용을 설명하는 하위 단계 작업을 자세히 설명합니다.
>  
> Java Virtual Machine Specification, Java SE 17판에서 스레드 및 잠금에 대한 정보는 Java Language Specification, Java SE 17판의 17장을 참조하십시오. 17장은 JSR 133 Expert Group에서 제작한 Java Memory Model 및 Thread Specification을 반영합니다.




# 1.4 Notation

이 specification 전체에서 우리는 Java SE Platform API에서 가져온 클래스와 인터페이스를 참조합니다. 우리가 단일 식별자 N을 사용하여 클래스나 인터페이스(예에서 선언된 것 이외의)를 참조할 때, 의도된 참조는 `java.lang` 패키지에서 N이라는 이름의 클래스나 인터페이스를 참조합니다. 우리는 `java.lang` 이외의 패키지에서 가져온 클래스나 인터페이스에 대해 정규화된 이름을 사용합니다.

package java 또는 하위 패키지에서 선언된 클래스 또는 인터페이스를 언급할 때마다 부트스트랩 클래스 로더에 의해 로드된 해당 클래스 또는 인터페이스를 참조합니다.

java라는 이름의 패키지의 하위 패키지를 참조할 때마다 부트스트랩 클래스 로더에 의해 결정된 해당 하위 패키지를 참조합니다.

- 고정 너비 글꼴은 JVM 데이터 유형에 사용됩니다.
  예외, 오류, 클래스 파일 구조, Prolog 코드 및 Java 코드 조각.
  
- 이탤릭체는 JVM의 `어셈블리 언어`, opcode 및 피연산자, 그리고 JVM의 런타임 데이터 영역의 항목에 사용됩니다. 
  또한 새로운 용어를 소개하고 단순히 강조하기 위해 사용됩니다.

규격을 명확히 하기 위해 설계된 비규범적 정보는 더 작은 들여쓰기 텍스트로 제공됩니다.
이것은 비규범적인 정보로 직관, 근거, 조언, 예시 등을 제공합니다.



# 1.5 Feedback

- 독자는 Java® Virtual Machine Specification의 기술적 오류와 모호성을 jls-jvms-spec-comments@openjdk.java.net 에 보고할 수 있습니다.  
- javac(자바 프로그래밍 언어의 참조 컴파일러)에 의한 클래스 파일 생성 및 조작에 관한 질문은 컴파일러- dev@openjdk.java.net 로 전송할 수 있습니다.