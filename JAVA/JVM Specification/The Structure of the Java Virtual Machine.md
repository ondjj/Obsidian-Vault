---
tags:
  - JVM
---
## 목차

1. [2.1_The_class_File_Format](#The_class_File_Format)
2. [2.2_Data_Types](#2.2_Data_Types)
3. [2.3_Primitive_Types_and_Values](#2.3_Primitive_Types_and_Values)
	1. [2.3.1_Integral_Types_and_Values](##2.3.1_Integral_Types_and_Values)
	2. [2.3.2_Floating_Point_Types_and_Values](##2.3.2_Floating_Point_Types_and_Values)
	3. [2.3.3_The_returnAddress_Type_and_Values](##2.3.3_The_returnAddress_Type_and_Values)
	4. [2.3.4_The_boolean_Type](##2.3.4_The_boolean_Type)
4. [2.4_Reference_Types_and_Values](#2.4_Reference_Types_and_Values])
5. [2.5_Run-Time_Data_Areas](#2.5_Run-Time_Data_Areas)


# 개요

이 문서에서는 추상적인 시스템에 대해 서술합니다. Java 가상 시스템의 특정 구현에 대해서는 설명하지 않습니다.
Java Virtural Machine을 올바르게 구현하려면 클래스 파일 형식을 읽고 클래스에 지정된 작업을 올바르게 수행하기만 하면 됩니다.
JVM의 사양에 포함되지 않은 구현 세부 정보는 불필요하게 구현자의 창의성을 제약합니다. 예를 들어 런타임 데이터 영역의 `메모리 레이아웃, 사용된 가바지 컬렉션 알고리즘, JVM 명령어의 내부 최적화(기계 코드로 변환)`는 구현자의 재량에 맡깁니다.

본 명세서의 유니코드에 대한 모든 참조는 [unicode](https://www.unicode.org/)에서 구할 수 있는 유니코드 표준 버전 13.0과 관련되어 있습니다.

# 2.1_The_class_File_Format

JVM이 실행할 컴파일된 코드는 하드웨어 및 운영 체제에 독립적인 이진 형식을 사용하여 표현하며, 일반적으로 클래스 파일 형식으로 알려져 있지만 반드시 그렇지는 않습니다. 클래스 파일 형식은 플랫폼별 개체 파일 형식에서 당연하게 여겨질 수 있는 바이트 순서와 같은 세부 정보를 포함하여 클래스 또는 인터페이스의 표현을 정확하게 정의합니다.
`Chapter 4 "The class File Format"` 에서는 클래스 파일 형식에 대해 자세히 설명합니다.


# 2.2_Data_Types

JVM은 자바 프로그래밍 언어와 마찬가지로 `primitive types`과 `reference types` 두 가지로 동작합니다. 따라서 변수에 저장되고 인수로 전달되며 메서에서 반환되거나 조작되는 값에는 기본형과 참조형 두 가지 종류가 있습니다.

일반적으로 JVM의 모든 유형 검사는 대부분 컴파일러에의해 런 타임 전에 수행되므로 JVM 자체에서 수행할 필요가 없습니다.기본 타입의 값은 런 타임에 타입을 결정 혹은 참조 타입의 값과 구별하기 위해 태그를 달거나 다른 방식으로 조사할 필요가 없습니다.
대신, JVM의 명령어 셋은 특정 타입의 값을 처리하기 위해 설계된 명령어를 사용하여 피연산자 타입을 구분합니다. 예를 들어 `iadd, ladd, fadd 및 dadd`는 모두 두 개의 숫자 값이 더해지고 숫자 결과가 생성되는 JVM  명령어이지만 각각은 int, long, float, double의 피연산자 유형에 특화되어 있습니다. JVM 명령어 셋에서 타입 지원 요약에 대한 자세한 내용은 `§2.11.1`을 참조하십시오.

JVM은 개체에 대한 명시적 지원을 포함합니다. 개체는 동적으로 할당된 클래스 인스턴스 또는 배열로 개체에 대한 참조는 JVM 유형 참조를 갖는 것으로 간주됩니다. 유형 참조의 값은 개체에 대한 포인터로 간주될 수 있고, 개체에 대한 참조가 둘 이상 존재할 수 있습니다.
개체는 항상 유형 참조의 값을 통해 동작되고, 전달되고, 테스트됩니다.




# 2.3_Primitive_Types_and_Values

JVM에서 지원하는 기본 데이터 유형은 `numeric types, boolean type (§2.3.4), returnAddress type (§2.3.3)`입니다.
숫자 유형은 `integral types (§2.3.1), floating-point types (§2.3.2)`으로 구성됩니다.

**integral types은 다음과 같습니다.**

- 바이트(byte) : 값은 8비트 부호가 있는 2의 정수이고 기본값은 0입니다.
- short : 값은 16비트 부호의 2의 정수이고 기본값은 0입니다.
- int : 값은 32비트 부호가 있는 2의 정수이고 기본값은 0입니다.
- long : 값은 64비트 부호가 있는 2의 정수이고 기본값은 0입니다.
- char : 기본 다국어 평면에서 유니코드 코드 포인트를 나타내는 16비트 비부호 정수를 UTF-16으로 인코딩하고 기본값은 null 코드 포인트('\u0000')입니다.

**floating-point types은 다음과 같습니다.**

- float : 값이 32비트 IEEE 754 바이너리 32형식으로 표시되는 값과 정확히 일치하고 기본값은 양의 0 입니다.
- double : 값이 64비트 IEEE 754 바이너리 64형식의 값과 정확히 일치하고 기본값은 양의 0 입니다.

`boolean` 유형의 값은 true 값과 false를 인코딩하며 기본값은 false입니다.
Java® Virtual Machine Specification의 First Edition에서는 `boolean을` JVM 유형으로 간주하지 않았습니다. 하지만 JVM에서는 `boolean` 값이 제한적으로 지원됩니다. Java® Virtual Machine Specification의 Second Edition에서는 `boolean을` 유형으로 취급하여 문제를 명확히 했습니다.`returnAddress`유형의 값은 JVM 명령의 `opcode`에 대한 포인터입니다. 기본 유형 중 `returnAddress` 유형만 Java 프로그래밍 언어 유형과 직접 연결되지 않습니다.


## 2.3.1_Integral_Types_and_Values

JVM의 integral types 유형 값은 다음과 같습니다.

- byte :  -128 to 127 (-$2^7$ to $2^7$ - 1), 포함
- short : -32768 to 32767 (-$2^{15}$ to $2^{15}$ - 1), 포함
- int : -2147483648 to 2147483647 ($-2^{31}$ to $2^{31}$ - 1), 포함
- long : - -9223372036854775808 to 9223372036854775807 ($-2^{63}$ to $2^{63}- 1$), 포함
- char :  0 ~ 65535, 포함

## 2.3.2_Floating_Point_Types_and_Values

floating-point type은 IEEE 754 표준(JLS § 1.7)에 명시된 대로 IEEE 754 값 및 연산을 위한 32-bit binary32 및 64-bit binary64 floating-point formats와 개념적으로 연관되어 있습니다.

Java SE 15 이상에서 JVM은 IEEE 754 Standard의 2019년 버전을 사용합니다. Java SE 15 이전에는 JVM이 IEEE 754 Standart의 1985년 버전을 사용했는데, 이때 binary32 형식은 단일 형식으로, binary64 형식은 이중 형식으로 알려졌습니다.

IEEE 754는 부호와 크기로 이루어진 양수와 음수 숫자 뿐만 아니라 양수와 음수 제로(zero), 양수와 음수 무한(infinity), 그리고 특수한 NaN(Not-a-Number) 값도 포함하고 있습니다. NaN 값은 0을 0으로 나누는 등의 특정한 유효하지 않은 연산의 결과를 나타내기 위해 사용됩니다. 부동 소수점(float)과 배정밀도(double)의 양식으로 정의된 NaN 상수는 Float.NaN과 Double.NaN으로 미리 정의되어 있습니다.

부동 소수점 타입의 유한한, 영이 아닌 값들은 다음 형식으로 모두 표현할 수 있습니다: s ⋅ m ⋅ 2^(e - N + 1) 여기서

- s는 +1 또는 -1입니다.
- m은 $2^N$ 미만인 양의 정수입니다.
- e는 Emin = $-(2^{K-1}-2)$부터 Emax = $2^{K-1}-1$까지 (포함)의 정수이며,
- N과 K는 해당 타입에 따라 달라지는 매개변수입니다.

일부 값들은 이 형식으로 여러 가지 방식으로 표현될 수 있습니다. 예를 들어, 어떤 부동 소수점 타입의 값 v가 특정한 s, m 및 e 값들을 사용하여 이 형식으로 표현될 수 있다고 가정해보겠습니다. 그리고 만약 m이 짝수이고 e가 $2^{K-1}$보다 작다면, m을 반으로 줄이고 e를 1 증가시켜 동일한 값 v에 대한 두 번째 표현을 생성할 수 있습니다.

이 형식으로 표현된 값이 m ≥ $2^{N-1}$인 경우, 정규화(normalized)된 것이라고 합니다. 그렇지 않은 경우, 표현은 아래수(subnormal)라고 합니다. 부동 소수점 타입의 값이 m ≥ $2^{N-1}$를 만족하는 방식으로 표현할 수 없다면, 해당 값은 아래수(subnormal) 값이라고 합니다. 이는 해당 값의 크기가 가장 작은 정규화된 값의 크기 미만이기 때문입니다.

매개변수 N과 K (그리고 파생된 매개변수 Emin과 Emax)에 대한 제약사항은 float와 double에 대한 Table 2.3.2-A에 요약되어 있습니다.

## 2.3.2-A. Floating-point parameters 표


![](https://i.imgur.com/5Ak5OfU.png)

NaN을 제외한 부동 소수점 값은 순서가 있습니다. 가장 작은 값부터 가장 큰 값까지 나열하면, 음의 무한대, 음의 유한한 영이 아닌 값, 양수와 음수 제로, 양의 유한한 영이 아닌 값, 그리고 양의 무한대입니다.

IEEE 754는 각각의 binary32와 binary64 부동 소수점 형식에 대해 여러 가지 다른 NaN 값을 허용합니다. 그러나 Java SE 플랫폼은 일반적으로 주어진 부동 소수점 형식의 NaN 값을 하나의 대표적인 값으로 취급하며, 이에 따라 이 명세서는 보통 임의의 NaN을 대표적인 값으로 언급합니다.

IEEE 754에 따라 NaN이 아닌 인자를 가지고 수행되는 부동 소수점 연산은 NaN 결과를 생성할 수 있습니다. IEEE 754는 일련의 NaN 비트 패턴을 지정하지만 NaN 결과를 나타내기 위해 어떤 특정한 NaN 비트 패턴을 사용해야 하는지를 강제하지 않으며, 이 부분은 하드웨어 아키텍처에 맡겨집니다. 프로그래머는 다른 비트 패턴을 가진 NaN을 생성하여 후행 진단 정보 등을 인코딩할 수 있습니다. 이러한 NaN 값은 각각 float 및 double에 대해 Float.intBitsToFloat 및 Double.longBitsToDouble 메서드를 사용하여 생성할 수 있습니다. 또한, NaN 값의 비트 패턴을 검사하기 위해서는 Float.floatToRawIntBits 및 Double.doubleToRawLongBits 메서드를 각각 float와 double에 대해 사용할 수 있습니다.

양의 제로와 음의 제로는 동등하게 비교됩니다. 그러나 그들을 구별할 수 있는 다른 연산도 있습니다. 예를 들어, 1.0을 0.0으로 나누면 양의 무한대가 생성되지만, 1.0을 -0.0으로 나누면 음의 무한대가 생성됩니다.

NaN은 순서가 없으므로 숫자 비교 및 숫자 동등성 테스트는 그들의 피연산자 중 하나 이상이 NaN인 경우 값이 false입니다. 특히, 어떤 값에 대한 숫자 동등성 테스트는 값이 NaN이면 값은 false이며, 숫자 불일치 테스트는 어떤 피연산자가 NaN인 경우 값이 true입니다.

## 2.3.3_The_returnAddress_Type_and_Values
  
returnAddress 유형은 자바 가상 머신의 jsr, ret 및 jsr_w 명령어에서 사용됩니다 (§jsr, §ret, §jsr_w). returnAddress 유형의 값은 자바 가상 머신 명령어의 `opcode`를 가리키는 포인터입니다. numeric primitive 타입과는 달리 returnAddress 유형은 어떤 자바 프로그래밍 언어 유형과도 대응하지 않으며 실행 중인 프로그램에서 수정할 수 없습니다.


## 2.3.4_The_boolean_Type

자바 가상 머신은 boolean 유형을 정의하지만, 이에 대한 매우 제한적인 지원만 제공합니다. 자바 가상 머신 명령어 중에서는 boolean 값을 처리하는 데 특화된 명령어가 없습니다. 
대신, 자바 프로그래밍 언어에서 boolean 값을 처리하는 표현식은 JVM int 데이터 유형의 값을 사용하도록 컴파일됩니다.

자바 가상 머신은 직접적으로 boolean 배열을 지원합니다. newarray 명령어(§newarray)를 사용하여 boolean 배열을 생성할 수 있습니다. boolean 유형의 배열은 byte 배열 명령어인 baload 및 bastore(§baload, §bastore)를 사용하여 액세스하고 수정합니다.

오라클의 자바 가상 머신 구현에서는 자바 프로그래밍 언어의 boolean 배열을 8비트로 인코딩한 JVM 바이트 배열로 처리합니다. 자바 프로그래밍 언어의 boolean 값이 컴파일러에 의해 자바 가상 머신 int 유형의 값으로 매핑되는 경우, 컴파일러는 동일한 인코딩을 사용해야 합니다. 여기서 1은 true를 나타내고 0은 false를 나타내는 데 사용됩니다.

# 2.4_Reference_Types_and_Values

Reference Types은 세 가지 종류가 있습니다:

- 클래스 유형, 배열 유형 및 인터페이스 유형입니다. 이들의 값은 동적으로 생성된 클래스 인스턴스, 배열 또는 인터페이스를 구현한 클래스 인스턴스 또는 배열에 대한 참조입니다.

- 배열 유형은 길이가 유형에 의해 지정되지 않는 단일 차원의 구성 유형으로 구성됩니다. 배열 유형의 구성 요소 유형 자체도 배열 유형일 수 있습니다. 어떤 배열 유형에서 시작하여 해당 구성 요소 유형을 고려하고, 그 구성 요소 유형도 배열 유형이라면, 그 유형의 구성 요소 유형을 고려하고 이를 반복하면, 결국 배열 유형이 아닌 구성 요소 유형에 도달해야 합니다. 이를 배열 유형의 요소 유형(element type)이라고 합니다. 배열 유형의 요소 유형은 반드시 원시 유형, 클래스 유형 또는 인터페이스 유형 중 하나여야 합니다.

- 참조 값은 특별한 null 참조일 수도 있으며, 이것은 어떠한 객체도 가리키지 않는 참조를 나타냅니다. 여기서는 null로 표시됩니다. null 참조는 처음에는 실행 시간 유형이 없지만, 어떤 유형으로든 형변환될 수 있습니다. 참조 유형의 기본 값은 null입니다. 이 명세서는 null 값을 구체적으로 인코딩하도록 규정하지 않습니다.


# 2.5_Run-Time_Data_Areas

JVM은 프로그램 실행 중에 사용되는 다양한 런타임 데이터 영역을 정의합니다.
이런 데이터 영역 중 일부는 JVM 시작 시 생성되며 머신이 종료될 때만 삭제됩니다. 다른 데이터 영역은 각각의 스레드 영역입니다. 스레드 데이터 영역은 스레드가 생성될 때 생성되고 스레드가 종료될 때 삭제됩니다.

## 2.5.1 The pc Register

JVM은 한 번에 많은 실행 스레드를 지원할 수 있습니다.(JLS ≥17) 각 JVM 스레드에는 고유한 PC(프로그램 카운터) 레지스터가 존재합니다. 어느 시점에서든 각 JVM 스레드는 단일 메서드의 코드, 즉 해당 스레드에 대한 현재 메서드(≥2.6)를 실행하고 있습니다. 이 메서드가 네이티브가 아니면 PC 레지스터에 현재 실행 중인 JVM 명령 주소가 포함됩니다. 스레드에서 현재 실행 중인 메서드가 네이티브이면 JVM의 PC 레지스터 값이 정의되지 않습니다. JVM PC 레지스터는 `returnAddress` 또는 특정 플랫폼의 네이티브 포인터를 저장할 수 있을 정도로 충분히 넓습니다.

## 2.5.2 Java Virtual Machine Stacks

각 JVM 스레드에는 스레드와 동시에 생성되는 전용 JVM 스택이 존재합니다. JVM 스택은 프레임 (≥2.6)을 저장합니다. JVM 스택은 C와 같은 일반적인 언어의 스택과 유사합니다. 로컬 변수의 부분적인 결과를 보유하고 메서드 호출 및 반환 역할을 담당합니다. JVM 스택은 푸시 프레임과 팝 프레임 외에는 직접 조작되지 않기 때문에 힙이 할당될 수 있습니다.
JVM 스택의 메모리는 연속적일 필요가 없습니다.

*Java® Virtual Machine Specification의 First Edition에서 Java Virtual Machine 스택은 Java 스택으로 알려졌습니다.*

이 규격에서 JVM 스택의 크기는 고정 값을 가지거나 계산에 필요한 대로 동적으로 확장 및 축소 할 수 있습니다. 스택의 크기가 고정되어 있으면 해당 스택을 생성할 때 각 JVM 스택의 크기를 독립적으로 선택할 수 있습니다.

*JVM 구현을 통해 프로그래머 또는 사용자가 JVM 스택의 초기 크기를 제어할 수 있을 뿐만 아니라 JVM 스택을 동적으로 확장하거나 축소하는 경우에도 최대 및 최소 크기를 제어할 수 있습니다.*

JVM 스택과 관련된 예외 조건은 다음과 같습니다.
- 스레드의 계산에 허용된 것보다 큰 JVM 스택이 필요한 경우 `StackOverflowError`를 발생시킵니다.
- JVM 스택을 동적으로 확장할 수 있고 확장을 시도했지만 사용 가능한 메모리가 부족해 확장 효과를 얻을 수 없거나 새 스레드에 대한 초기 JVM 스택을 생성하기에 메모리가 부족한 경우 JVM이 `OutOfMemoryError`를 발생시킵니다.

## 2.5.3 Heap

JVM에는 모든 JVM 스레드 간에 공유되는 힙이 있습니다. 힙은 모든 클래스 인스턴스 및 어레이의 메모리가 할당되는 런타임 데이터 영역입니다.

힙은 가상 시스템 시작 시 생성됩니다. 개체에 대한 힙 스토리지는 `가비지 컬렉터`라고 하는 자동 스토리지 관리 시스템에 의해 회수되며, 개체의 할당이 명시적으로 해제되지는 않습니다. JVM은 특정 유형의 자동 스토리지 관리 시스템을 가정하지 않으며, 스토리지 관리 기술은 구현자의 시스템 요구 사항에 따라 선택할 수 있습니다.

힙은 고정된 크기이거나 계산에서 필요한 대로 확장될 수 있으며, 더 큰 힙이 필요 없게 되면 축소될 수 있습니다. 힙의 메모리는 연속적일 필요가 없습니다.

*JVM 구현은 힙의 초기 크기에 대한 프로그래머 또는 사용자의 제어권을 제공할 수 있을 뿐만 아니라 힙을 동적으로 확장하거나 축소할 수 있는 경우에는 최대 및 최소 힙 크기에 대한 제어권을 제공할 수 있습니다.*

힙과 관련된 예외 조건은 다음과 같습니다:

-  자동 스토리지 관리 시스템에서 계산에 사용할 수 있는 것보다 더 많은 힙이 필요한 경우 JVM에서 `OutOfMemoryError`가 발생합니다.

## 2.5.4 Method Area

JVM에는 모든 JVM 스레드 간에 공유되는 메소드 영역이 존재합니다. 메소드 영역은 기존 언어의 컴파일된 코드의 저장 영역과 유사하거나 운영 체제 프로세스의 "텍스트" 세그먼트와 유사합니다.
클래스 및 인터페이스 초기화 및 인스턴스 초기화(§2.9)에서 사용되는 특수 메소드를 포함하여 `run-time constant pool, field and method data, the code for methods and constructors`의  코드와 같은 클래스별 구조를 저장합니다.

메소드 영역은 JVM 시작 시 생성됩니다. 메소드 영역이 논리적으로 힙의 일부이긴 하지만 간단한 구현은 가비지 컬렉션이나 압축을 선택하지 않을 수 있습니다. 본 명세서에서는 메소드 영역의 위치나 컴파일된 코드를 관리하는 데 사용되는 정책을 요구하지 않습니다. 메소드 영역은 고정된 크기이거나 계산에서 요구하는 대로 확장될 수 있으며 더 큰 메소드 영역이 불필요해지면 축소될 수 있습니다. 메소드 영역에 대한 메모리는 연속적일 필요가 없습니다.

*JVM 구현은 프로그래머 또는 사용자에게 메서드 영역의 초기 크기에 대한 제어를 제공할 수 있으며, 크기가 다른 메서드 영역의 경우에는 최대 및 최소 메서드 영역 크기에 대한 제어를 제공할 수 있습니다.*

메소드 영역에는 다음과 같은 예외 조건이 존재합니다.

- 메서드 영역의 메모리를 사용하여 할당을 충족할 수 없는 경우 요청이 들어오면 JVM에서 `OutOfMemoryError`을 발생시킵니다.


## 2.5.5 Run-Time Constant Pool

`run-time constant pool`은 클래스 파일에 있는 constant_pool 테이블의 클래스 단위 또는 인터페이스 단위의 런타임 표현입니다.(§4.4) 컴파일 타임에 알려진 숫자 리터럴부터 런타임에 해결해야 하는 메서드 및 필드 참조에 이르기까지 여러 종류의 상수를 포함합니다.
`run-time constant pool`은 일반적인 `symbol 테이블`보다 더 넓은 범위의 데이터를 포함하지만 기존 프로그래밍 언어의 `symbol 테이블`과 유사한 기능을 합니다.

`run-time constant pool`은 JVM의 메서드 영역에서 할당됩니다.(§2.5.4) 클래스 또는 인터페이스의 런타임 상수 풀은 JVM이 클래스 또는 인터페이스를 생성할 때(§5.3) 구성됩니다.

클래스 또는 인터페이스의 `run-time constant pool` 구성과 관련된 예외 조건은 다음과 같습니다:

- 클래스 또는 인터페이스를 생성할 때 `run-time constant pool`을 구성할 때 JVM 메서드 영역에서 사용할 수 있는 메모리보다 더 많은 메모리가 필요하면 JVM에서 `OutOfMemoryError`가 발생합니다.

*`run-time constant pool`의 구성에 대한 내용은 §5 (Loading, Linking, and Initializing)를 참조하십시오.*

## 2.5.6 Native Method Stacks

JVM의 구현은 네이티브 메소드(Java 프로그래밍 언어가 아닌 언어로 쓰여진 메소드)를 지원하기 위해 `"C 스택"`이라고 불리는 기존의 스택을 사용할 수 있습니다. 네이티브 메소드 스택은 C와 같은 언어로 된 자바 가상 머신의 명령 셋에 대한 인터프리터 구현에 의해서도 사용될 수 있습니다. 네이티브 메소드를 로드할 수 없고 기존의 스택에 의존하지 않는 JVM 구현은 네이티브 메소드 스택을 제공할 필요가 없습니다. 제공되는 경우 네이티브 스택은 일반적으로 각 스레드가 생성될 때 각각의 스레드에 할당됩니다.

본 명세서는 네이티브 메소드 스택들이 고정된 크기이거나 계산에 의해 요구되는 대로 동적으로 확장 및 축소될 수 있도록 허용합니다. 네이티브 메소드 스택들이 고정된 크기인 경우, 각 네이티브 메소드 스택의 크기는 해당 스택이 생성될 때 독립적으로 선택될 수 있습니다.

*JVM 구현을 통해 프로그래머 또는 사용자가 네이티브 메소드 스택의 초기 크기를 제어할 수 있을 뿐만 아니라 크기가 다양한 네이티브 메소드 스택의 경우 최대 및 최소 메소드 스택 크기를 제어할 수 있습니다.*

Native method stacks과 관련된 예외 조건은 다음과 같습니다.

- 허용된 산정 수치보다 더 큰 native method stack이 필요한 경우 JVM에서 `StackOverflowError`가 발생합니다.
- native method stack을 동적으로 확장할 수 있고 네이티브 메소드 스택을 확장하려고 하지만 메모리가 부족한 경우 또는 메모리가 부족하여 새 스레드에 초기 네이티브 메소드 스택을 생성할 수 없는 경우 JVM이 `OutOfMemoryError`을 발생시킵니다.

## 2.6 Frames