
- 규칙 1. 한 메서드는 오직 한 단계의 들여쓰기(indent)만 한다.
- 규칙 2. else 예약어를 사용하지 않는다.
- 규칙 3. 모든 원시값과 문자열을 포장한다.
- 규칙 4. 한 줄에 점을 하나만 찍는다.
- 규칙 5. 줄여쓰지 않는다.(축약 금지)
- 규칙 6. 모든 엔티티는 작게 유지한다.
- 규칙 7. 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
- 규칙 8. 일급 콜렉션을 쓴다.
- 규칙 9. 게터/세터/프로퍼티를 쓰지 않는다.
# 규칙 1. 한 메서드에 오직 한 단계의 들여쓰기(indent)만 한다.

"One level of indentation per method" 원칙은 객체 지향 프로그래밍과 코드 디자인에서 깨끗하고 가독성 있는 코드를 작성하기 위한 지침 중 하나입니다.
이 원칙은 잘 구조화된 메서드에서 들여쓰기 수준을 하나로 유지하도록 권장하는 규칙으로 이를 준수할 경우 메서드를 짧게 유지하고, 하나의 작업에 집중할 수 있는 환경을 구성하게됩니다.

## 가독성 향상
메서드에 들여쓰기가 하나만 있는 경우, 일반적으로 메서드가 한가지 목적을 수행하게되면 그만큼 코드의 길이가 짧아지고 이해하기 쉬운 코드가 되기 때문에 다른 개발자 혹은 미래에 다시 코드를 들여다 보게 될 나에게 더 확실한 정보를 전달할 수 있습니다.

## 유지 보수성
하나의 목적에 충실한 메서드는 유지 및 수정에 용이하고, 변경을 수행하기 위해 중첩된 함수를 훑어 다니지 않아도 됩니다.

## 재사용성
단일 책임을 갖는 메서드는 코드베이스의 다른 부분에서 재사용 가능성이 높아지고 이는 곧 DRY(Don't Repeat Yourself) 원칙을 장려하며 동일한 작업을 다시 반복하지 않게 해줍니다.

## 테스트
단일 책임을 갖는 메서드에 대한 단위 테스트는 작성하기 쉽습니다. 해당 메서드의 기능이 구체적이기 때문에 그만큼 올바른 테스트를 작성하고, 동작을 확인할 수 있습니다.

물론 "One level of indentation per method" 원칙을 준수하려면 코드를 작게 유지하는 연습이 필요한데, 만약 내가 작성한 코드의 들여쓰기 수준이 높다면 리팩터링이 필요한 시점이라고 생각할 수 있습니다.

예를 들어 아래와 같이 CarNames 클래스가 존재할 때, `extractCarNames()` 메서드는 이름 분할, 유효성 검사, 좌우 공백 제거까지 총 세 가지 역할을 하고있고, 들여쓰기 레벨 역시 준수하지 않고 있습니다.

``` java
public class CarNames {  
    private final String value;  
  
    public CarNames(String carName) {  
        this.value = carName;  
    }
      
	public List<String> extractCarNames() { 
		String[] names = value.split(COMMA_DELIMITER); 
		List<String> carNames = new ArrayList<>(); 
		
		for (String name : names) {
			if(name == null || name.isEmpty()){
				throw new IllegalArgumentException("");
			}
			carNames.add(name.trim()); 
		} 
		return carNames; 
	}
}
```

이 클래스를 규칙 1에 맞춰 개선하면 다음과 같이 변경할 수 있습니다.

```java
public class CarNames {  
    private static final String COMMA_DELIMITER = ",";  
    private static final String EXCEPTION_MESSAGE = "유효하지않은 입력입니다.";  
  
    private final String value;  
  
    public CarNames(String carName) {  
        hasNotNUllEmpty(carName);  
        this.value = carName;  
    }  
  
    public List<String> extractCarNames() {  
        String[] names = splitCarNames();  
        return trimCarNames(names);  
    }  
  
    private String[] splitCarNames() {  
        return value.split(COMMA_DELIMITER);  
    }  
  
    private List<String> trimCarNames(final String[] names) {  
        return Arrays.stream(names)  
                .map(String::trim)  
                .collect(Collectors.toList());  
    }  
  
    private void hasNotNUllEmpty(String value) {  
        if (value == null || value.isEmpty()) {  
            throw new IllegalArgumentException(EXCEPTION_MESSAGE);  
        }  
    }  
}
```


# 규칙 2. else 예약어를 사용하지 않는다.

"else 사용하지 않기" 원칙은 객체 지향 프로그래밍에서 코드를 더 읽기 쉽고 모듈화하며 이해하기 쉽도록 작성하는데 중점을 둡니다. else 문이 적은 코드는 일반적으로 더 읽기 쉽고, 일련의 조건 검사와 특정 작업으로 구성되어 코드의 동작이 더 명시적으로 다가오고 복잡한 로직을 피해 더 작고 집중된 메서드를 작성할 수 있는 환경을 조성할 수 있습니다. 이에 따라 각 메서드는 조건 논리의 특정 부분에 대해 책임을 가지게 되고 이는 단일 책임 원칙으로 이어집니다.
논리 로직에 따라 컨디션이 변경되지 않기 때문에 더 간단한 제어 흐름을 갖게 되므로 버그 발생 가능성이 줄어들고 프로그램 동작에 대한 이해가 쉬워집니다.

## 테스트
직관적인 코드 구성을 통해 효과적인 단위 테스트를 수행할 수 있습니다.

이 원칙을 준수하기 위해선 `early return`, 다형성, 또는 패턴 매칭과 같은 기술을 사용하여 else 문의 사용을 제거하거나 줄이는 방법을 고려할 수 있습니다.

```java
public int processData(String data) {
	if(data == null){
		return -1; // else 사용 불필요
	}
	// 데이터 로직 처리 ..
	int result = validProcessing(data);
	return result;
}
```

# 규칙 3. 모든 원시값과 문자열을 포장한다.

