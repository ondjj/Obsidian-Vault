## 안녕하세요 👋 방문해주셔서 감사합니다.

이번 로또 미션은 지난 시간에 진행한 레이싱 카에서 받은 피드백을 최대한 녹여내고자 노력했습니다.

제가 받은 주요 피드백은 다음과 같습니다. [레이싱 카 미션]([https://github.com/woowacourse-precourse/java-racingcar-6/pull/529](https://github.com/woowacourse-precourse/java-racingcar-6/pull/529 "https://github.com/woowacourse-precourse/java-racingcar-6/pull/529"))

- MVC 패턴을 적용해볼것 (특히 View 계층 도입)
- 일급 컬렉션을 적극적으로 활용해볼것
- 검증과 관련된 클래스 도입 
## 1. 무엇을 고민했는가
3주차 로또 미션의 추가 요구 사항 항목 중 `핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 분리해 구현한다.` 라는 부분이 있었는데요.
저는 이 부분이 MVC 패턴을 유도하는 문항 중 하나였다고 생각합니다. 마침 지난 시간에 받은 피드백과 같은 맥락으로 이번 미션은 MVC 패턴을 적극적으로 도입하고자했습니다.
## 2. 무엇을 배웠는가
### 2.1 모델, 컨트롤러, 뷰의 경계 지점
테스트에서도 중요하게 살펴 보는 것 중 하나가 경계 값 테스트인만큼, 상당수의 문제점이 이 경계 지점 설정에 있다고 생각합니다.
처음 목표는 비교적 간단하다 판단한 View 계층을 오직 UI와 관련된 항목으로 구성하는것으로 잡았고 어렵지않게 구현할 수 있었습니다.

하지만, 모델과 뷰를 작성하고 나니 `ProfitControlle` 가 지나치게 복잡하다는 느낌을 받게되었고 
`calculateTotalPrize` 에서 값의 여부를 판단하고, 합계를 도출하는 형태로 코드가 자리잡힌것을 확인했습니다.
이는 명백히 처음 의도와 다르게 컨트롤러에서 모델의 역할을 수행하고 있는것이라 생각되었고 관련된 부분을 개선할 수 있었습니다.
``` java
private long calculateTotalPrize(Map<String, Integer> compareResult) {
        return compareResult.entrySet().stream()
                .filter(this::shouldIncludeEntry)
                .mapToLong(this::calculatePrizeForEntry)
                .sum();
    }

private boolean shouldIncludeEntry(Map.Entry<String, Integer> entry) {
        Optional<LottoResult> result = LottoResult.fromDescription(entry.getKey());
        return result.isPresent() && entry.getValue() > ZERO;
    }

private long calculatePrizeForEntry(Map.Entry<String, Integer> entry) {
        Optional<LottoResult> result = LottoResult.fromDescription(entry.getKey());
        return result.map(lottoResult -> (long) lottoResult.getPrize() * entry.getValue()).orElse(LONG_ZERO);
    }
```

### 2.2 일급 컬렉션 활용 그리고 검증
문제 요구 사항에 주어진 `Lotto` 외에도 직접 일급 컬렉션을 생성해보고, 이를 유용하게 다뤄보고싶었습니다.
마침 입력으로 들어오는 데이터 중, 여러 개의 입력 값을 다뤄야하는 `당첨 번호` 를 통해 일급 컬렉션을 구현 해 볼 수 있었고
동시에 검증을 담당하는 클래스를 통해 역할을 분배할 수 있었습니다.
``` java
public class WinningNumbers {  
    private final List<Integer> winning;  
  
    public WinningNumbers(String winning) {  
        validateWinningNumbers(winning);  
        this.winning = Parser.parseString(winning).stream()  
                .map(Integer::valueOf)  
                .sorted()  
                .toList();  
    }  
  
    public boolean contains(Integer number) {  
        return winning.contains(number);  
    }  
}
```

## 3. 개선점
- 디자인 패턴을 적용해보고싶다는 생각은 있지만, 어디서부터 어떻게 적용하는게 좋을지 조금 막막하네요😂
- TDD로 개발을 한다면, 컨트롤러에서 일어난 실수가 줄어들거란 생각이 들었습니다.

## 패키지 구조

|    Package     |        Class         |                       Description                        |
|:--------------:|:--------------------:|:--------------------------------------------------------:|
| **Controller** | **LottoController**  |                사용자 입력을 관리합니다.                 |                                  
|                | **ProfitController** |                수익률 출력을 관리합니다.                 |                                
|                |                      |                                                          |                    
|   **Domain**   |      **Lotto**       |           `Lotto` 객체를 생성하고 관리합니다.            |                                  
|                |   **BonusNumber**    |            사용자 입력을 랩핑한 클래스입니다.            |                                   
|                |  **WinningNumbers**  |         사용자 입력을 랩핑한 일급 컬렉션입니다.          |                                    
|                |  **PurchaseAmount**  |            사용자 입력을 랩핑한 클래스입니다.            |                                 
|                | **BundleGenerator**  |     `PurchaseAmount`를 통해 로또 번호를 생성합니다.      |                                  
|                |   **LottoBundle**    |        최종적으로 검증된 로또 번들을 관리합니다.         |                                  
|                | **ProfitCalculator** |                   수익률을 계산합니다.                   |                              
|                | **ResultComparator** |   생성된 로또와 입력을 비교하고, 결과를 만들어냅니다.    |                                  
|                |                      |                                                          |                                
|   **util**    |                      |                                                          |                                  
|     enums      |   **ErrorMessage**   |              전체 에러 메시지를 관리합니다.              |                                 
|                |   **LottoResult**    |       결과 메시지, 매치 카운트, 상금을 관리합니다.       |                                   
|   exception    |                      |    예외를 상속 받고, 알맞은 예외 메시지를 처리합니다.    |                                  
|   validators   |                      | 로직에 대한 유효성 검사를 처리하고, 예외를 발생시킵니다. |                                   
|                |                      |                                                          |                                
|    **View**    |                      |                                                          |                         
|                |    **InputView**     |                      사용자의 입력을 처리하는 뷰 클래스                                   |  
|                |    **OutputView**    | 사용자의 출력을 처리하는 뷰 클래스                                                         |                                    |     |     |




## 기능 목록

### 로또 번호 생성
- [ - ] 사용자로부터 구입 금액을 입력 받는다.
    - `1,000` 단위가 아니거나, 잘못된 입력일 경우 예외 처리를 상세하게 진행한다.

- [ - ] 1부터 45사이의 6개의 랜덤 숫자를 생성한다. -NumberGenerator#createLottoNumber (일급 컬렉션 고려)
  - 중복되는 숫자가 존재해선 안된다.
  - 발행한 로또 수량 및 번호를 출력한다. 
  - 로또 번호는 오름차순으로 정렬하여 보여준다.

### 당첨 번호 생성
- [ - ] 사용자로부터 중복 되지 않은 6개의 당첨 번호를 입력 받는다.
    - 번호는 쉼표(,)를 기준으로 구분한다.
    - 당첨 번호와 중복 되지 않은 보너스 번호 1개를 입력 받는다.

- [ - ] 사용자 입력이 잘못된 경우 `IllegalArgumentException` 를 발생시킨다.
  - `"[ERROR]"`로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.
  - `Exception` 이 아닌 `IllegalArgumentException`, `IllegalStateException` 등과 같은 명확한 유형을 처리한다.


### 로또 번호, 당첨 번호 검증 
- [ - ] 로또 번호와 당첨 번호를 비교한다.
  - 1등부터 5등까지 당첨 통계를 낸다.
  - 통계 내역을 출력한다.

### 수익률 계산
- [ - ] 수익률을 계산한다.
  - 수익률 내역을 출력한다.

### 입력 유효성 검사
#### [ - ] 구입 금액 입력 유효성 검사
1. 사용자가 입력한 구입 금액이 `1,000`원 단위로 떨어지지않는 경우 예외를 발생시킨다.
2. 사용자가 입력한 구입 금액이 정수가 아닌 경우 예외를 발생시킨다.
3. 사용자가 입력한 구입 금액이 비어있을 경우 예외를 발생시킨다.
4. 사용자가 입력한 구입 금액이 `0`일 경우 예외를 발생시킨다.

#### [ - ] 당첨 번호, 보너스 번호 입력 유효성 검사
1. 사용자가 입력한 당첨 번호가 `1 - 45` 사이의 숫자가 아닌 경우 예외를 발생시킨다.
2. 사용자가 입력한 당첨 번호가 정수가 아닌 경우 예외를 발생시킨다.
3. 사용자가 입력한 당첨 번호가 문자열, null, Empty일 경우 예외를 발생시킨다.

## 주의 사항
- 로또 번호의 숫자 범위는 1부터 45까지이다.
- 1개의 로또를 발행할 때 중복되지 않는 6개의 숫자를 뽑는다.
- 당첨 번호 추첨 시 중복되지 않는 숫자 6개와 보너스 번호 1개를 뽑는다.
- 당첨은 1등부터 5등까지 있다. 당첨 기준과 금액은 아래와 같다.
  - 1등: 6개 번호 일치 / 2,000,000,000원
  - 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
  - 3등: 5개 번호 일치 / 1,500,000원
  - 4등: 4개 번호 일치 / 50,000원
  - 5등: 3개 번호 일치 / 5,000원

## 추가 요구 사항

1. 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
2. else 예약어를 쓰지 않는다.
3. Java Enum을 적용한다. - 예외처리 메시지 Enum 처리 할 수 있음.
4. 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(System.out, System.in, Scanner) 로직은 제외한다.
   핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 분리해 구현한다. - MVC 패턴 사용 유도>)
# 요구 사항과 함께 주어진 것

```java
public class Lotto {  
    private final List<Integer> numbers;  
  
    public Lotto(List<Integer> numbers) {  
        validate(numbers);  
        this.numbers = numbers;  
    }  
  
    private void validate(List<Integer> numbers) {  
        if (numbers.size() != 6) {  
            throw new IllegalArgumentException();  
        }  
    }  
  
    // TODO: 추가 기능 구현  
}
```


안녕하세요 프리코스 진행중인 예비 6기 지원자 전창준입니다😊
이번 미션 로또는 지난 소감문에 기재했던 `적극적으로 리뷰 받기`를 충실히 이행하고 거기서 받은 피드백을 중심으로 진행해봤습니다. 총 12분께서 제 코드에 대한 리뷰를 남겨주셨는데, 하나 하나 모두 주옥같은 멘트를 남겨주셔서 이번 미션 진행에 큰 도움이 되었던거 같습니다 !

제가 받은 주요 피드백은 총 네 가지로 다음과 같습니다.
1. MVC 패턴을 사용해보기 (특히 View 계층 도입)
2. 일급 컬렉션 활용
3. 검증 클래스를 도입
4. 상수 활용

MVC 패턴 사용해보기
마침 이번 미션과도 이어지는 부분이 있어 더욱 충실하게 피드백을 지켜나갈 수 있었습니다.
물론 누군가 이전까지 MVC 패턴의 존재를 모르고 있었는지 묻는다면, 알고는 있다 라고 대답은 할 수 있었겠지만
모델, 뷰, 컨트롤러 각 계층의 책임은 무엇이고 경계 지점을 어떻게 선별할것인지에 대해 묻는다면 쉽사리 답할 수 없었을거 같습니다.

예를 들어 저는 미션을 시작하면서 가장 먼저 확정한 계층은 뷰 계층으로 단순히 입출력만을 할 수 있게 잘 구성했다고 생각합니다. 하지만 모델을 구현하고 이를 컨트롤러와 연결하면서 어느 순간 컨트롤러가 지나치게 길어진다는 느낌을 받았고 코드를 천천히 되짚어 보니 컨트롤러에서 값의 여부를 판단하고, 합계를 도출하는 형태로 자리가 잡혀있는것을 확인할 수 있었는데요. 이는 명백히 처음 의도했던 바와 다르게 모델의 기능을 컨트롤러에서 수행하는 것이라는 알 수 있었습니다. 이렇게 직접 잘못된 코드 흐름을 피부로 느껴보니 각 레이어의 경계 지점을 어떻게 선정해야할지 기준이 잡혔고, 패턴에 대한 이해가 깊어졌습니다.

일급 컬렉션 활용(feat.랩핑 클래스)
주어진 Lotto 클래스도 일급 컬렉션이지만, 직접 생성한 일급 컬렉션으로 이번 미션을 풀어나가보고싶었습니다.
이에 당첨 번호를 일급 컬렉션으로 만들고, contains라는 메서드를 명명해 제가 만든 일급 컬렉션으로 미션을 풀어나갈 수 있었습니다. 외에도 추가로 들어오는 다른 입력 값 모두 랩핑해 사용해보니 이렇게 객체를 랩핑하고, 코드를 풀어나가면 내부를 자세히 들여다보지 않더라도 단순히 코드를 읽는것만으로도 '어떤 작업이 진행되고 있구나' 라고 파악할 수 있다는 것이었습니다. 

검증 클래스 도입
이 부분은 커뮤니티에서도 이슈가 되는 항목이지만, 도입 해 본 결과 검증 항목이 많아질수록 적극적으로 도입 하는게 좋다는 결론이 들었습니다. 특히 우테코 미션 처럼 외부 입력이 많은 항목들은 랩핑 클래스를 통해 검증을 할 수 있으니, 객체 자체에 대한 간섭도 줄어들어 이전보다 코드 품질이 향상되었다고 느꼈습니다.

상수 활용
매직 넘버 역시 코드 품질을 향상 시켜주는 감초 역할을 한다는것을 새삼 다시 느낄 수 있었습니다.
다만 아직 고민이 되는 것은, 여러 곳에서 공통으로 사용되는 항목을 클래스에 모아 활용해도 되는것인지 확신이 서지 않지만 이는 부가적인 문제로 매직 넘버 사용은 어렵지 않지만 부가 가치는 상당히 좋았습니다.

다음으로 제가 생각했을때 개선해야할 부분에 대해 고민해봤습니다.
먼저 디자인 패턴 적용에 대한 부분인데요. 디자인 패턴이 무엇인지 알고있지만, 깊게 공부해보지않아 어떤 상황에 어떤 패턴을 사용해야할지 아직은 막막하다는 느낌이 들어 이 부분에 대해 조금 더 시간을 투자해야할 필요를 느끼고있습니다. 이번 로또 미션도 충분히 더 좋은 구조를 가질 수 있었을텐데 패턴에 대한 무지로 그렇지 못한다는게 너무 너무 아쉽습니다. 모든 미션이 끝난 후에라도 패턴을 적용해보며 개선해봐야겠습니다.

TDD 역시 전부터 적용해보고싶은 개발 방법론 중 하나이지만 아쉽게도 이번 미션에선 이를 활용해 개발하지 못 했습니다. 다음 미션은 어떤게 나올지 모르지만 구현 결과를 떠나 적용한다는것에 의의를 두고 반드시 적용해 볼 예정입니다.
생각의 전환이 필요한 항목으로 여겨지는데 이번 기회에 자신감 있는 코드를 짜보고싶습니다.

마지막으로 이번 미션을 진행하면서 개인적으로 아쉬운 부분 중 하나로 예외 처리에 대한 내용입니다.
지금 제가 예외를 처리한 형태는 다음과 같은데요.

|- abstract MathOperationException extends ArithmeticException
|- *Exception extends MathOperationException

이렇게 추상 클래스를 통해 예외를 확장하다 보니 예외의 개 수가 늘어나면 늘어날 수록 이를 구현하는 클래스가 계속해서 생겨나는 형태입니다. 어떻게 보면 개발하는 입장에서 명확한 이름을 가진 예외 클래스를 통해 쉽게 문제점을 파악할 수 있지만 더 좋은 방법이 있을거 같아 계속해서 개선점을 찾아가는 중입니다.

로또 미션을 진행하면서 한가지 흥미로웠던 점은 enum의 활용이었습니다.
'LottoResult'로 정의한 enum을 통해 각 결과에 대한 설명, 일치 개수, 상금과 같은 정보를 저장할 수 있었고 이를 통해 유의미한 결과를 도출하는 과정을 진행하고나니 상황에 맞는 자료구조를 잘 사용하는것도 개발자의 역량 중 하나라는걸 상기할 수 있었습니다.

점점 어려워지고 구체화 되가는 미션의 요구 사항에 맞춰 문제를 바라보니, 생각이 확장되어가는것을 느낄 수 있는 요즘입니다. 어제보다 오늘 더 고민거리가 늘어나는게 거기에 집중하고 있는게 살아있다는 느낌마저 들게 만드는게 놀랍기도 하네요. 다음 미션도 기대가 됩니다!