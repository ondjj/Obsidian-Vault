---
tistoryBlogName: ondj
tistoryTitle: CQRS 아는척 하기
tistoryTags: CQRS,Architecuture
tistoryVisibility: "0"
tistoryCategory: "1096106"
tistorySkipModal: true
tistoryPostId: "122"
tistoryPostUrl: https://ondj.tistory.com/122
---
[명령 모델이란? - Command Query Responsibility Segregation :: CQRS 아는척하기](https://www.youtube.com/watch?v=xf0kXMTFJm8)

**명령 (Command)**
- 시스템의 데이터를 변경하는 기능을 말한다.
- 기능 예 (주문 취소, 배송 완료)

**쿼리 (Query)**
- 시스템의 데이터 조회를 조회하는 기능을 말한다.
- 기능 예 (주문 목록)

**책임 (Responsibility)**
- 구성 요소의 역할
- 구성 요소(모델)
	- 클래스, 함수
	- 모듈/패키지
	- 웹서버/DB

**분리 (Segregation)**
- 역할에 따라 구성 요소 나눈다는것을 뜻한다.

![](https://velog.velcdn.com/images/ondj/post/32288f8e-5290-4c4c-9bd9-0451248e553e/image.png)

좀 더 간단히 말하면 시스템 데이터를 변경하는 코드와 시스템 데이터를 조회하는 코드를 따로 만드는것이 CQRS이다. (주의할 점으로 코드만 나누는것이 아닌 구현 방식이나 시스템 규모에 따라 DB를 나누기도하고 프로세스를 나누기도 한다.)

![](https://velog.velcdn.com/images/ondj/post/ecb37056-74d6-4641-a69a-24ced6133be3/image.png)

변경을 위한 커멘드 패키지와 조회를 위한 쿼리 패키지로 나눠서 따로 관리하는 예시이다. 패키지에 속한 구성 요소는 각각 목적에 맞게 구성되어 있지만 코드가 중복되고, 개발이 느려지는 느낌을 받을 수 있다.

왜 사용할까?

만약 단일 모델을 사용해 명령과 조회를 수행한다면, 역할과 책임의 경계가 모호해지고 이에 따라 의미와 가독성이 나빠져 유지 보수성이 떨어지는 결과를 얻게된다.

그렇다면 복잡해진 시스템에서 커멘드와 쿼리의 단일 모델을 고수하면 유지 보수성이 왜 떨어질까?

1. **명령과 쿼리는 다루는 데이터가 다르기 때문이다.**
명령은 한 영역의 데이터를 다루는 반면 쿼리는 시스템이 복잡해질수록 여러 영역의 데이터를 다루는 경향이 있다.
(주문 취소와 같은 명령은 `오더 - 오더 라인`만 다루지만 회원 목록 조회나 주문 목록 조회같은 기능은 주문, 회원, 상품 영역의 데이터를 사용하게 된다.)

2. ** 명령과 쿼리는 코드 변경 빈도, 사용자도 다르다.**
변경 빈도가 다른 기능이 한 코드에 있으면 서로 다른 이유로 코드가 바뀌고, 이는 곧 책임의 크기가 적당하지 않다는 것이다.

3. **기능마다 트래픽 패턴, 요구하는 성능이 다르다.**
(상품 목록 조회와 백오피스의 판매 수치를 예로 생각해보자)
기능마다 서로 다른 성능 향상 방법이 필요하지만 단일 모델로는 다양한 성능 향상 기법 적용이 어려울 수 있다.

이런 이유로 명령과 쿼리를 구분한다.

---